Apesar de gostar muito de desenvolvimento front-end, provavelmente o que mais me da vontade de estudar √© back-end (e me divirto bem mais), visando isso estou estudando GO, e aqui est√° algumas das minhas anota√ß√µes.

Antes de irmos a fundo, quero citar algumas coisas que achei interessantes na linguagem. Come√ßando pela promessa de compatibilidade que o Go tem enraizada: eles n√£o tomam decis√µes que afetam vers√µes anteriores. Isso √© muito legal üëç

Outro ponto √© o Cross Compilation, que permite compilar para diversos sistemas operacionais independentemente do S.O. em que voc√™ estiver. Diferente do Electron, por exemplo (pelo menos at√© onde sei), onde, se quiser gerar um build para macOS, voc√™ precisa necessariamente ter um Mac.

Se tiver usando vscode: Ctrl + Shift + P ‚Üí Go Install/Update Tools

## B√°sicos da Linguagem

### Go CLI

-   `go mod init NomePasta` - Criando go.mod
-   `go run main.go` - Compila e executa o projeto
-   `go build main.go` - Compila o projeto
-   `go build -o "app" main.go` - Compila o projeto e nomeia como app.exe
-   `go get` - Instala algum package
-   `go install` - Compila e instala um package
-   `go test` - Roda algum teste relacionado ao projeto

## Packages e Organiza√ß√£o de C√≥digo

### Como os packages (pacotes) funcionam?

Em Go existem dois tipos de pacotes: **Execut√°veis** e **Reutiliz√°veis**

O `package main` √© um pacote execut√°vel, ele precisa ter uma fun√ß√£o main dentro, o nome do arquivo em si n√£o importa, poderia ser qualquercoisa.go mas se tiver a fun√ß√£o main ele √© o pacote execut√°vel. Esse √© o pacote principal, o que √© usado pra buildar o projeto.

Se tentar buildar um projeto com um pacote que n√£o seja o main, ele n√£o vai gerar o execut√°vel. E como saber se um pacote √© execut√°vel ou reutiliz√°vel?.

-   Se for `package main`, √© execut√°vel.
-   Qualquer outro nome, tipo `package utils`, `package math`, √© reutiliz√°vel, ou seja, c√≥digo que pode ser usado em outros lugares como se fosse uma depend√™ncia.

### Importa√ß√µes

```go

import "fmt"

import (
	"marcus/pacote"
	"fmt"
)


// Renomeando pacote na Importa√ß√£o
import (
	marcus "fmt"
)

func main() {
	//fmt.Println("Hello World");
	marcus.Println("Hello World");
}
```

### Criando um Pacote

Para criar um pacote, basta criar uma pasta com o nome desejado, por exemplo "alfabeto". Dentro dela, coloque os arquivos Go:

-   `a.go`
-   `b.go`

Em todos os arquivos dentro dessa pasta, a primeira linha deve declarar o mesmo pacote:

```go
package alfabeto
```

Se, por exemplo, voc√™ definir uma constante em `a.go`

```go
package alfabeto

const Idade = 30
```

Poder√° acess√°-la em outro arquivo importando o pacote:

```go
package main

import (
	"meuprojeto/alfabeto"
	"fmt"
)

func main() {
	fmt.Println(alfabeto.Idade) //30
}
```

Como todos os arquivos da pasta pertencem ao mesmo pacote, qualquer fun√ß√£o, constante ou vari√°vel exportada (iniciada com letra mai√∫scula) pode ser acessada ao importar o pacote.

#### Pacotes Internos

`Estrutura de pastas`

```
meuprojeto/
‚îÇ
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ pacote/
‚îÇ   ‚îú‚îÄ‚îÄ b.go
‚îÇ   ‚îî‚îÄ‚îÄ internal/
‚îÇ       ‚îî‚îÄ‚îÄ foo/
‚îÇ           ‚îî‚îÄ‚îÄ foo.go
```

`pacote/internal/foo/foo.go`

```go
package foo

// Essa vari√°vel s√≥ pode ser acessada dentro de "pacote"
var Minha = "Sou interna"
```

`pacote/b.go`

```go
package pacote

import (
	"fmt"
	"meuprojeto/pacote/internal/foo"
)

// Fun√ß√£o p√∫blica que usa a vari√°vel interna
func PrintMinha() {
	fmt.Println(foo.Minha)
}
```

`main.go`

```go
package main

import (
	"meuprojeto/pacote"
	"fmt"
)

func main() {
	// Correto: acessamos atrav√©s de b.go
	pacote.PrintMinha()

	// Errado: isso n√£o compila, acesso direto √© proibido
	// fmt.Println(foo.Minha)
	fmt.Println("N√£o √© poss√≠vel importar foo diretamente fora de 'pacote'")
}
```

## Tipos de Dados e Vari√°veis

### Variav√©is

Em Go, nomes que come√ßam com letra mai√∫scula s√£o exportados (p√∫blicos) e podem ser acessados fora do pacote.

```go
const name string = "Marcus" // Privada
const Name string = "Marcus" // P√∫blica

// Vari√°veis de escopo de pacote; N√£o precisam ser inicializadas nem usadas imediatamente
var global string

func main() {
    // Vari√°veis declaradas dentro de fun√ß√µes devem ser usadas depois de inicializadas;
	// caso contr√°rio, ocorre erro.
    var name2 string = "Marcus" // Tipo Expl√≠cito
    name3 := "Marcus"          // Infer√™ncia de Tipo (s√≥ em escopo de fun√ß√£o)

    // Declara√ß√£o m√∫ltipla de vari√°veis de tipos diferentes
    foo, bar := true, 50
}
```

Em Go n√£o existe undefined ou null como em outras linguagens. Se voc√™ n√£o inicializar a vari√°vel, ela vir√° com um **zero value** dependendo do tipo:

-   string ‚Üí ""
-   int ‚Üí 0
-   float ‚Üí 0
-   boolean ‚Üí false

Tipos em Go:

-   String: `string`
-   Boolean: `bool`
-   Inteiros: `int`, `int8`, `int16`, `int32`, `int64` e `uint`, `uint8`, `uint16`, `uint32`, `uint64`
-   Aliases: `byte` (equivalente a `uint8`), `rune` (equivalente a `int32`)
-   Ponto flutuante: `float32`, `float64`
-   N√∫meros complexos: `complex64`, `complex128`

Usando esses mesmos tipos podemos mudar o tipo de uma vari√°vel:

```go
var x int = 10
var y float64 = float64(x)
```

## Fun√ß√µes

### Fun√ß√µes B√°sicas

Criando uma fun√ß√£o que retorna string:

```go
func myName() string {
    return "Marcus"
}

// Quando n√£o colocamos o tipo na primeira vari√°vel, o Go entende que todas s√£o do mesmo tipo.
func abc(a, b int) {}

// Uma fun√ß√£o pode retornar 2 valores
func numbers() (int, int) {
	return 10, 20
}

// Podemos dar nome √†s vari√°veis de retorno. Isso ajuda na leitura e documenta√ß√£o.
func dividir(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return res, resto
}

// Naked return - N√£o √© encorajado usar!
// Como j√° nomeamos as vari√°veis de retorno, n√£o precisamos especific√°-las no return.
func dividirNaked(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return
}

func main() {
	// Fun√ß√µes An√¥nimas
	foo := func() {
		fmt.Println("Hello")
	}

	foo()
}
```

### Higher Order Functions

```go
func main() {
	x := somar(2)(1)
}

// Fun√ß√£o de higher order: retorna outra fun√ß√£o
// Essa fun√ß√£o retornada √© chamada de closure
func somar(a int) func(int) int {
	return func(b int) int {
		return a + b
	}
}
```

### Fun√ß√£o Vari√°tica

```go
// Fun√ß√£o vari√°tica: aceita 1 ou mais argumentos
func somarVariatica(nums ...int) int {
	var out int
	for _, n := range nums {
		out += n
	}
	return out
}

// somarVariatica(10, 10, 10) => 30
```

## Estruturas de Dados

### Arrays

Arrays tem tamanho fixo, nunca podem crescer ou diminuir

```go
	var arr1 [5]int
	var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
	arr3 := [5]int{3: 10} // inicializa o indice 3 com valor 10
	arr4 := [10]int{3: 10, 6: 20} // inicializa os indices 3 e 6 com valores 10 e 20
```

### Slices

Uma Slice √© uma vers√£o din√¢mica de um Array.

-   Use `Array` quando o tamanho da lista for fixo.
-   Use `Slice` quando o tamanho for vari√°vel.

Slices precisam ter todos os elementos do mesmo tipo.

Quando usamos `append()`, na real estamos criando uma nova Slice com o novo valor incluso e reatribuindo essa nova Slice pra mesma vari√°vel.

Pra iterar sobre uma Array ou Slice, usamos a palavra-chave `range` no loop, que percorre cada elemento.

```go
// Criando uma Slice a partir de um Array

arr := [5]int{1, 2, 3, 4, 5}
//criando o Slice pegando do index 1 a 3 do Array
//colocamos 4 pois ele descarta o ultimo
//nome disso: Slice Range Syntax
sliceArr := arr[1:4] // [2,3,4]
//mesmo alterando depois de criar o Slice, a Array tbm √© modificada
//pois apontam pro mesmo endere√ßo de memoria
arr[2] = 65
fmt.Println(sliceArr)

// Criando uma Slice

//para criar um slice basta apenas criar um array
//mas sem limitar os espa√ßos
slice := []int{1, 2, 3}
fmt.Println(slice)

// todo Slice tem Length e Capacity
// Length -> quantidade de elementos salvos no presente
// Capacity -> quantidade que o Slice pode armazenar sem fazer outra aloca√ß√£o
fmt.Println(slice, len(slice), cap(slice))
//Para adicionar um elemento no Slice criamos outro Slice e Reatribuimos
slice = append(slice, 2)
fmt.Println(slice, len(slice), cap(slice))

// Ao usar append em slices sem capacidade pr√©-alocada, cada vez que for necess√°rio
// aumentar o espa√ßo, o Go realocar√° a mem√≥ria e dobrar√° a capacidade do slice
// Em loops isso pode gerar muitas realoca√ß√µes, impactando negativamente a performance

// Uma forma mais eficiente de criar slices √© com make
// Com make podemos definir o tipo, o tamanho inicial (length) e a capacidade
// garantindo que o espa√ßo j√° esteja pr√©-alocado na mem√≥ria
// Essa abordagem √© √∫til principalmente quando sabemos previamente
// o tamanho do Slice
slicePerformatico := make([]string, 0, 10)
fmt.Println(slicePerformatico, len(slicePerformatico), cap(slicePerformatico))
```

## Controle de Fluxo

### Condicionais

As condicionais em Go s√£o feitas com `if`, `else if`, `else` e `switch`.
N√£o tem diferencia entre else if e switch em termos de performance, ent√£o use o que fizer mais sentido pro seu caso.

```go
func main() {
	a := 10

	// Condicional if / else if / else
	if a > 5 {
		fmt.Println("maior que 5")
	} else if a < 5 {
		fmt.Println("menor que 5")
	} else {
		fmt.Println("igual a 5")
	}

	// Vari√°vel declarada no if
	// e s√≥ existe dentro do escopo do if
	if b := 5; b < 10 {
		fmt.Println("b menor que 10")
	}

	// Switch case
	switch a {
	case 1:
		fmt.Println("a √© 1")
		fallthrough // executa o pr√≥ximo case mesmo que a condi√ß√£o n√£o seja verdadeira
	case 2, 3, 4:
		fmt.Println("a √© 2, 3 ou 4")
	case 6:
		fmt.Println("a √© 6")
	default:
		fmt.Println("a √© maior que 5")
	}

	// Switch sem express√£o: √∫til para substituir longos if else if else
	switch {
	case a < 5:
		fmt.Println("a √© menor que 5")
	case "abc" == "foo": // podemos usar express√µes
		fmt.Println("a √© igual a foo")
	case a > 5:
		fmt.Println("a √© maior que 5")
	}

	// Vari√°vel declarada no switch s√≥ existe dentro do escopo do switch
	switch b := 5; {
	case b < 10:
		fmt.Println("b menor que 10")
	}
}

```

### Loops

Os Loops em Go s√£o feitos com a palavra-chave `for`. N√£o existe while ou do while, mas podemos usar o for de forma que ele funcione como esses outros tipos de loop.

```go
func main() {
    // Loop for tradicional: inicializa√ß√£o, condi√ß√£o e incremento
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

    // Loop for usado como while: com apenas condi√ß√£o
	i := 0
	for i < 10 {
		i++
		fmt.Println(i)
	}

    // Loop for com range em array: pega index e valor
	arr := [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index, value)
	}

    // Loop for com range ignorando o index (_), pegando s√≥ o valor
	for _, value := range arr {
		fmt.Println(value)
	}

    // Loop for com range em n√∫mero (0 at√© 9)
	for range 10 {
		fmt.Println("loop")
	}

    // Loop for com range em n√∫mero (0 at√© 9) e pegando o index
	for index := range 10 {
		fmt.Println(index, "loop")
	}
}
```

## Conceitos Avan√ßados

### Defer

A palavra-chave `defer` adia a execu√ß√£o de uma fun√ß√£o at√© que a fun√ß√£o que a cont√©m retorne. Ou seja, o c√≥digo marcado com `defer` s√≥ ser√° executado no final, mesmo que esteja no meio da fun√ß√£o.

```go
func defer() {
	// Adia a execu√ß√£o de uma fun√ß√£o at√© o fim da fun√ß√£o que a chamou
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("func√£o principal")
	// sa√≠da:
	// fun√ß√£o principal
	// defer 2
	// defer 1
}
```

### Ponteiros

Os ponteiros s√£o uma maneira de referenciar a localiza√ß√£o de uma vari√°vel na mem√≥ria, ao inv√©s de seu valor. Isso √© √∫til quando queremos modificar o valor original de uma vari√°vel dentro de uma fun√ß√£o.

Quando temos `*` na frente de um tipo, estamos dizendo que √© um ponteiro. `ex: x *int,`

Quando temos `*` na frente de uma vari√°vel, estamos fazendo um dereference. `ex: *a`

```go
func main() {
	x := 10
	pointer := &x // &x √© o endere√ßo de mem√≥ria da vari√°vel x
	fmt.Println(pointer, *pointer)
	//*pointer estou fazendo um dereference
	//ou seja, estou pegando o valor que est√° no endere√ßo de mem√≥ria
	//que a vari√°vel pointer (&x) est√° apontando

	take(&x) //passando o endere√ßo de mem√≥ria da vari√°vel x
	//dentro da fun√ß√£o take, o valor que est√° no endere√ßo de mem√≥ria
	//da vari√°vel x ser√° alterado para 20
	//pois estamos passando o endere√ßo de mem√≥ria da vari√°vel x
	//e dentro da fun√ß√£o take, estamos alterando o valor que est√° nesse endere√ßo de mem√≥ria
	//se n√£o fiz√©ssemos isso, o valor de x continuaria 10
	//pois estar√≠amos passando uma c√≥pia do valor de x
	//e n√£o o endere√ßo de mem√≥ria de x
	fmt.Println(x)
}

// x *int √© um ponteiro para um inteiro
func take(x *int) {
	*x = 20
}
```

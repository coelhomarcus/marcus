Apesar de gostar muito de desenvolvimento front-end, provavelmente o que mais me da vontade de estudar é back-end (e me divirto bem mais), visando isso estou estudando GO, e aqui está algumas das minhas anotações.

Antes de irmos a fundo, quero citar algumas coisas que achei interessantes na linguagem. Começando pela promessa de compatibilidade que o Go tem enraizada: eles não tomam decisões que afetam versões anteriores. Isso é muito legal 👍

Outro ponto é o Cross Compilation, que permite compilar para diversos sistemas operacionais independentemente do S.O. em que você estiver. Diferente do Electron, por exemplo (pelo menos até onde sei), onde, se quiser gerar um build para macOS, você precisa necessariamente ter um Mac.

Se tiver usando vscode: Ctrl + Shift + P → Go Install/Update Tools

## Básicos da Linguagem

### Go CLI

-   `go mod init NomePasta` - Criando go.mod
-   `go run main.go` - Compila e executa o projeto
-   `go build main.go` - Compila o projeto
-   `go build -o "app" main.go` - Compila o projeto e nomeia como app.exe
-   `go get` - Instala algum package
-   `go install` - Compila e instala um package
-   `go test` - Roda algum teste relacionado ao projeto

## Packages e Organização de Código

### Como os packages (pacotes) funcionam?

Em Go existem dois tipos de pacotes: **Executáveis** e **Reutilizáveis**

O `package main` é um pacote executável, ele precisa ter uma função main dentro, o nome do arquivo em si não importa, poderia ser qualquercoisa.go mas se tiver a função main ele é o pacote executável. Esse é o pacote principal, o que é usado pra buildar o projeto.

Se tentar buildar um projeto com um pacote que não seja o main, ele não vai gerar o executável. E como saber se um pacote é executável ou reutilizável?.

-   Se for `package main`, é executável.
-   Qualquer outro nome, tipo `package utils`, `package math`, é reutilizável, ou seja, código que pode ser usado em outros lugares como se fosse uma dependência.

### Importações

```go

import "fmt"

import (
	"marcus/pacote"
	"fmt"
)


// Renomeando pacote na Importação
import (
	marcus "fmt"
)

func main() {
	//fmt.Println("Hello World");
	marcus.Println("Hello World");
}
```

### Criando um Pacote

Para criar um pacote, basta criar uma pasta com o nome desejado, por exemplo "alfabeto". Dentro dela, coloque os arquivos Go:

-   `a.go`
-   `b.go`

Em todos os arquivos dentro dessa pasta, a primeira linha deve declarar o mesmo pacote:

```go
package alfabeto
```

Se, por exemplo, você definir uma constante em `a.go`

```go
package alfabeto

const Idade = 30
```

Poderá acessá-la em outro arquivo importando o pacote:

```go
package main

import (
	"meuprojeto/alfabeto"
	"fmt"
)

func main() {
	fmt.Println(alfabeto.Idade) //30
}
```

Como todos os arquivos da pasta pertencem ao mesmo pacote, qualquer função, constante ou variável exportada (iniciada com letra maiúscula) pode ser acessada ao importar o pacote.

#### Pacotes Internos

`Estrutura de pastas`

```
meuprojeto/
│
├── main.go
├── pacote/
│   ├── b.go
│   └── internal/
│       └── foo/
│           └── foo.go
```

`pacote/internal/foo/foo.go`

```go
package foo

// Essa variável só pode ser acessada dentro de "pacote"
var Minha = "Sou interna"
```

`pacote/b.go`

```go
package pacote

import (
	"fmt"
	"meuprojeto/pacote/internal/foo"
)

// Função pública que usa a variável interna
func PrintMinha() {
	fmt.Println(foo.Minha)
}
```

`main.go`

```go
package main

import (
	"meuprojeto/pacote"
	"fmt"
)

func main() {
	// Correto: acessamos através de b.go
	pacote.PrintMinha()

	// Errado: isso não compila, acesso direto é proibido
	// fmt.Println(foo.Minha)
	fmt.Println("Não é possível importar foo diretamente fora de 'pacote'")
}
```

## Tipos de Dados e Variáveis

### Variavéis

Em Go, nomes que começam com letra maiúscula são exportados (públicos) e podem ser acessados fora do pacote.

```go
const name string = "Marcus" // Privada
const Name string = "Marcus" // Pública

// Variáveis de escopo de pacote; Não precisam ser inicializadas nem usadas imediatamente
var global string

func main() {
    // Variáveis declaradas dentro de funções devem ser usadas depois de inicializadas;
	// caso contrário, ocorre erro.
    var name2 string = "Marcus" // Tipo Explícito
    name3 := "Marcus"          // Inferência de Tipo (só em escopo de função)

    // Declaração múltipla de variáveis de tipos diferentes
    foo, bar := true, 50
}
```

Em Go não existe undefined ou null como em outras linguagens. Se você não inicializar a variável, ela virá com um **zero value** dependendo do tipo:

-   string → ""
-   int → 0
-   float → 0
-   boolean → false

Tipos em Go:

-   String: `string`
-   Boolean: `bool`
-   Inteiros: `int`, `int8`, `int16`, `int32`, `int64` e `uint`, `uint8`, `uint16`, `uint32`, `uint64`
-   Aliases: `byte` (equivalente a `uint8`), `rune` (equivalente a `int32`)
-   Ponto flutuante: `float32`, `float64`
-   Números complexos: `complex64`, `complex128`

Usando esses mesmos tipos podemos mudar o tipo de uma variável:

```go
var x int = 10
var y float64 = float64(x)
```

## Funções

### Funções Básicas

Criando uma função que retorna string:

```go
func myName() string {
    return "Marcus"
}

// Quando não colocamos o tipo na primeira variável, o Go entende que todas são do mesmo tipo.
func abc(a, b int) {}

// Uma função pode retornar 2 valores
func numbers() (int, int) {
	return 10, 20
}

// Podemos dar nome às variáveis de retorno. Isso ajuda na leitura e documentação.
func dividir(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return res, resto
}

// Naked return - Não é encorajado usar!
// Como já nomeamos as variáveis de retorno, não precisamos especificá-las no return.
func dividirNaked(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return
}

func main() {
	// Funções Anônimas
	foo := func() {
		fmt.Println("Hello")
	}

	foo()
}
```

### Higher Order Functions

```go
func main() {
	x := somar(2)(1)
}

// Função de higher order: retorna outra função
// Essa função retornada é chamada de closure
func somar(a int) func(int) int {
	return func(b int) int {
		return a + b
	}
}
```

### Função Variática

```go
// Função variática: aceita 1 ou mais argumentos
func somarVariatica(nums ...int) int {
	var out int
	for _, n := range nums {
		out += n
	}
	return out
}

// somarVariatica(10, 10, 10) => 30
```

## Estruturas de Dados

### Arrays

Arrays tem tamanho fixo, nunca podem crescer ou diminuir

```go
	var arr1 [5]int
	var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
	arr3 := [5]int{3: 10} // inicializa o indice 3 com valor 10
	arr4 := [10]int{3: 10, 6: 20} // inicializa os indices 3 e 6 com valores 10 e 20
```

### Slices

Uma Slice é uma versão dinâmica de um Array.

-   Use `Array` quando o tamanho da lista for fixo.
-   Use `Slice` quando o tamanho for variável.

Slices precisam ter todos os elementos do mesmo tipo.

Quando usamos `append()`, na real estamos criando uma nova Slice com o novo valor incluso e reatribuindo essa nova Slice pra mesma variável.

Pra iterar sobre uma Array ou Slice, usamos a palavra-chave `range` no loop, que percorre cada elemento.

```go
// Criando uma Slice a partir de um Array

arr := [5]int{1, 2, 3, 4, 5}
//criando o Slice pegando do index 1 a 3 do Array
//colocamos 4 pois ele descarta o ultimo
//nome disso: Slice Range Syntax
sliceArr := arr[1:4] // [2,3,4]
//mesmo alterando depois de criar o Slice, a Array tbm é modificada
//pois apontam pro mesmo endereço de memoria
arr[2] = 65
fmt.Println(sliceArr)

// Criando uma Slice

//para criar um slice basta apenas criar um array
//mas sem limitar os espaços
slice := []int{1, 2, 3}
fmt.Println(slice)

// todo Slice tem Length e Capacity
// Length -> quantidade de elementos salvos no presente
// Capacity -> quantidade que o Slice pode armazenar sem fazer outra alocação
fmt.Println(slice, len(slice), cap(slice))
//Para adicionar um elemento no Slice criamos outro Slice e Reatribuimos
slice = append(slice, 2)
fmt.Println(slice, len(slice), cap(slice))

// Ao usar append em slices sem capacidade pré-alocada, cada vez que for necessário
// aumentar o espaço, o Go realocará a memória e dobrará a capacidade do slice
// Em loops isso pode gerar muitas realocações, impactando negativamente a performance

// Uma forma mais eficiente de criar slices é com make
// Com make podemos definir o tipo, o tamanho inicial (length) e a capacidade
// garantindo que o espaço já esteja pré-alocado na memória
// Essa abordagem é útil principalmente quando sabemos previamente
// o tamanho do Slice
slicePerformatico := make([]string, 0, 10)
fmt.Println(slicePerformatico, len(slicePerformatico), cap(slicePerformatico))
```

## Controle de Fluxo

### Condicionais

As condicionais em Go são feitas com `if`, `else if`, `else` e `switch`.
Não tem diferencia entre else if e switch em termos de performance, então use o que fizer mais sentido pro seu caso.

```go
func main() {
	a := 10

	// Condicional if / else if / else
	if a > 5 {
		fmt.Println("maior que 5")
	} else if a < 5 {
		fmt.Println("menor que 5")
	} else {
		fmt.Println("igual a 5")
	}

	// Variável declarada no if
	// e só existe dentro do escopo do if
	if b := 5; b < 10 {
		fmt.Println("b menor que 10")
	}

	// Switch case
	switch a {
	case 1:
		fmt.Println("a é 1")
		fallthrough // executa o próximo case mesmo que a condição não seja verdadeira
	case 2, 3, 4:
		fmt.Println("a é 2, 3 ou 4")
	case 6:
		fmt.Println("a é 6")
	default:
		fmt.Println("a é maior que 5")
	}

	// Switch sem expressão: útil para substituir longos if else if else
	switch {
	case a < 5:
		fmt.Println("a é menor que 5")
	case "abc" == "foo": // podemos usar expressões
		fmt.Println("a é igual a foo")
	case a > 5:
		fmt.Println("a é maior que 5")
	}

	// Variável declarada no switch só existe dentro do escopo do switch
	switch b := 5; {
	case b < 10:
		fmt.Println("b menor que 10")
	}
}

```

### Loops

Os Loops em Go são feitos com a palavra-chave `for`. Não existe while ou do while, mas podemos usar o for de forma que ele funcione como esses outros tipos de loop.

```go
func main() {
    // Loop for tradicional: inicialização, condição e incremento
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

    // Loop for usado como while: com apenas condição
	i := 0
	for i < 10 {
		i++
		fmt.Println(i)
	}

    // Loop for com range em array: pega index e valor
	arr := [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index, value)
	}

    // Loop for com range ignorando o index (_), pegando só o valor
	for _, value := range arr {
		fmt.Println(value)
	}

    // Loop for com range em número (0 até 9)
	for range 10 {
		fmt.Println("loop")
	}

    // Loop for com range em número (0 até 9) e pegando o index
	for index := range 10 {
		fmt.Println(index, "loop")
	}
}
```

## Conceitos Avançados

### Defer

A palavra-chave `defer` adia a execução de uma função até que a função que a contém retorne. Ou seja, o código marcado com `defer` só será executado no final, mesmo que esteja no meio da função.

```go
func defer() {
	// Adia a execução de uma função até o fim da função que a chamou
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("funcão principal")
	// saída:
	// função principal
	// defer 2
	// defer 1
}
```

### Ponteiros

Os ponteiros são uma maneira de referenciar a localização de uma variável na memória, ao invés de seu valor. Isso é útil quando queremos modificar o valor original de uma variável dentro de uma função.

Quando temos `*` na frente de um tipo, estamos dizendo que é um ponteiro. `ex: x *int,`

Quando temos `*` na frente de uma variável, estamos fazendo um dereference. `ex: *a`

```go
func main() {
	x := 10
	pointer := &x // &x é o endereço de memória da variável x
	fmt.Println(pointer, *pointer)
	//*pointer estou fazendo um dereference
	//ou seja, estou pegando o valor que está no endereço de memória
	//que a variável pointer (&x) está apontando

	take(&x) //passando o endereço de memória da variável x
	//dentro da função take, o valor que está no endereço de memória
	//da variável x será alterado para 20
	//pois estamos passando o endereço de memória da variável x
	//e dentro da função take, estamos alterando o valor que está nesse endereço de memória
	//se não fizéssemos isso, o valor de x continuaria 10
	//pois estaríamos passando uma cópia do valor de x
	//e não o endereço de memória de x
	fmt.Println(x)
}

// x *int é um ponteiro para um inteiro
func take(x *int) {
	*x = 20
}
```

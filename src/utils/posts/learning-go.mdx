Apesar de gostar muito de desenvolvimento front-end, provavelmente o que mais me da vontade de estudar é back-end (e me divirto bem mais), visando isso estou estudando GO, e aqui está algumas das minhas anotações.

Antes de irmos a fundo, quero citar algumas coisas que achei interessantes na linguagem. Começando pela promessa de compatibilidade que o Go tem enraizada: eles não tomam decisões que afetam versões anteriores. Isso é muito legal `B^)`

Outro ponto é o Cross Compilation, que permite compilar para diversos sistemas operacionais independentemente do S.O. em que você estiver. Diferente do Electron, por exemplo (pelo menos até onde sei), onde, se quiser gerar um build para macOS, você precisa necessariamente ter um Mac.

Se tiver usando vscode: Ctrl + Shift + P → Go Install/Update Tools

## Básicos da Linguagem

### Go CLI

-   **go mod init NomePasta** - Criando go.mod
-   **go run main.go** - Compila e executa o projeto
-   **go build main.go** - Compila o projeto
-   **go build -o "app" main.go** - Compila o projeto e nomeia como app.exe
-   **go get** - Instala algum package
-   **go install** - Compila e instala um package
-   **go test** - Roda algum teste relacionado ao projeto

## Packages e Organização de Código

### Como os packages (pacotes) funcionam?

Em Go existem dois tipos de pacotes: **Executáveis** e **Reutilizáveis**

O **package main** é um pacote executável, ele precisa ter uma função main dentro, o nome do arquivo em si não importa, poderia ser qualquercoisa.go mas se tiver a função main ele é o pacote executável. Esse é o pacote principal, o que é usado pra buildar o projeto.

Se tentar buildar um projeto com um pacote que não seja o main, ele não vai gerar o executável. E como saber se um pacote é executável ou reutilizável?.

-   Se for **package main**, é executável.
-   Qualquer outro nome, tipo **package utils**, **package math**, é reutilizável, ou seja, código que pode ser usado em outros lugares como se fosse uma dependência.

### Importações

```go

import "fmt"

import (
	"marcus/pacote"
	"fmt"
)


// Renomeando pacote na Importação
import (
	marcus "fmt"
)

func main() {
	//fmt.Println("Hello World");
	marcus.Println("Hello World");
}
```

### Criando um Pacote

Para criar um pacote, basta criar uma pasta com o nome desejado, por exemplo "alfabeto". Dentro dela, coloque os arquivos Go:

-   a.go
-   b.go

Em todos os arquivos dentro dessa pasta, a primeira linha deve declarar o mesmo pacote:

```go
package alfabeto
```

Se, por exemplo, você definir uma constante em **a.go**

```go
package alfabeto

const Idade = 30
```

Poderá acessá-la em outro arquivo importando o pacote:

```go
package main

import (
	"meuprojeto/alfabeto"
	"fmt"
)

func main() {
	fmt.Println(alfabeto.Idade) //30
}
```

Como todos os arquivos da pasta pertencem ao mesmo pacote, qualquer função, constante ou variável exportada (iniciada com letra maiúscula) pode ser acessada ao importar o pacote.

#### Pacotes Internos

**Estrutura de pastas**

```
meuprojeto/
│
├── main.go
├── pacote/
│   ├── b.go
│   └── internal/
│       └── foo/
│           └── foo.go
```

**pacote/internal/foo/foo.go**

```go
package foo

// Essa variável só pode ser acessada dentro de "pacote"
var Minha = "Sou interna"
```

**pacote/b.go**

```go
package pacote

import (
	"fmt"
	"meuprojeto/pacote/internal/foo"
)

// Função pública que usa a variável interna
func PrintMinha() {
	fmt.Println(foo.Minha)
}
```

**main.go**

```go
package main

import (
	"meuprojeto/pacote"
	"fmt"
)

func main() {
	// Correto: acessamos através de b.go
	pacote.PrintMinha()

	// Errado: isso não compila, acesso direto é proibido
	// fmt.Println(foo.Minha)
	fmt.Println("Não é possível importar foo diretamente fora de 'pacote'")
}
```

## Tipos de Dados e Variáveis

### Variavéis

Em Go, nomes que começam com letra maiúscula são exportados (públicos) e podem ser acessados fora do pacote.

```go
const name string = "Marcus" // Privada
const Name string = "Marcus" // Pública

// Variáveis de escopo de pacote; Não precisam ser inicializadas nem usadas imediatamente
var global string

func main() {
    // Variáveis declaradas dentro de funções devem ser usadas depois de inicializadas;
	// caso contrário, ocorre erro.
    var name2 string = "Marcus" // Tipo Explícito
    name3 := "Marcus"          // Inferência de Tipo (só em escopo de função)

    // Declaração múltipla de variáveis de tipos diferentes
    foo, bar := true, 50
}
```

Em Go não existe undefined ou null como em outras linguagens. Se você não inicializar a variável, ela virá com um **zero value** dependendo do tipo:

-   string → ""
-   int → 0
-   float → 0
-   boolean → false

Tipos em Go:

-   String: `string`
-   Boolean: `bool`
-   Inteiros: `int`, `int8`, `int16`, `int32`, `int64` e `uint`, `uint8`, `uint16`, `uint32`, `uint64`
-   Aliases: `byte` (equivalente a `uint8`), `rune` (equivalente a `int32`)
-   Ponto flutuante: `float32`, `float64`
-   Números complexos: `complex64`, `complex128`

Usando esses mesmos tipos podemos mudar o tipo de uma variável:

```go
var x int = 10
var y float64 = float64(x)
```

## Funções

### Funções Básicas

Criando uma função que retorna string:

```go
func myName() string {
    return "Marcus"
}

// Quando não colocamos o tipo na primeira variável, o Go entende que todas são do mesmo tipo.
func abc(a, b int) {}

// Uma função pode retornar 2 valores
func numbers() (int, int) {
	return 10, 20
}

// Podemos dar nome às variáveis de retorno. Isso ajuda na leitura e documentação.
func dividir(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return res, resto
}

// Naked return - Não é encorajado usar!
// Como já nomeamos as variáveis de retorno, não precisamos especificá-las no return.
func dividirNaked(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return
}

func main() {
	// Funções Anônimas
	foo := func() {
		fmt.Println("Hello")
	}

	foo()
}
```

### Higher Order Functions

```go
func main() {
	x := somar(2)(1)
}

// Função de higher order: retorna outra função
// Essa função retornada é chamada de closure
func somar(a int) func(int) int {
	return func(b int) int {
		return a + b
	}
}
```

### Função Variática

```go
// Função variática: aceita 1 ou mais argumentos
func somarVariatica(nums ...int) int {
	var out int
	for _, n := range nums {
		out += n
	}
	return out
}

// somarVariatica(10, 10, 10) => 30
```

## Estruturas de Dados

### Arrays

Arrays tem tamanho fixo, nunca podem crescer ou diminuir

```go
	var arr1 [5]int
	var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
	arr3 := [5]int{3: 10} // inicializa o indice 3 com valor 10
	arr4 := [10]int{3: 10, 6: 20} // inicializa os indices 3 e 6 com valores 10 e 20
```

### Slices

Uma Slice é uma versão mais flexível de um Array.

-   Use `Array` quando o tamanho da lista for fixo.
-   Use `Slice` quando o tamanho for variável - já que dá pra adicionar ou remover elementos com facilidade.

Slices precisam ter todos os elementos do mesmo tipo: se começou com **int**, tudo tem que ser **int**;

Quando usamos **append()**, na real estamos criando uma nova Slice com o novo valor incluso e reatribuindo essa nova Slice pra mesma variável.

Pra iterar sobre uma Array ou Slice, usamos a palavra-chave **range** no loop, que percorre cada elemento.

```go
// Criando uma Slice

names := []string{"Marcus", myName(), "Vitoria"}

// Adicionando novo elemento na Slice

names = append(names, "Coelho")

//Iterando pela Slice

for index, name := range names {
    fmt.Println(index, name);
}

//Iterando sem index

for _, name := range names {
    fmt.Println(name);
}
```

#### Slice Range Syntax

Esse esquema de fatia (slice) é muito útil quando queremos pegar só uma parte da lista.

Detalhe importante: o segundo número não é incluso, então 0:2 pega o índice 0 e 1.

```go
fruits := []string{"Maçã", "Pera", "Banana", "Uva"}

// Do índice 0 até o 2 (mas sem incluir o 2)

fruits[0:2] == ["Maçã", "Pera"]
fruits[:2]   == ["Maçã", "Pera"]

// A partir do índice 2 (incluindo o 2) até o fim

fruits[2:] == ["Banana", "Uva"]
```

## Controle de Fluxo

### Condicionais

As condicionais em Go são feitas com **if**, **else if**, **else** e **switch**.
Não tem diferencia entre else if e switch em termos de performance, então use o que fizer mais sentido pro seu caso.

```go
func main() {
	a := 10

	// Condicional if / else if / else
	if a > 5 {
		fmt.Println("maior que 5")
	} else if a < 5 {
		fmt.Println("menor que 5")
	} else {
		fmt.Println("igual a 5")
	}

	// Variável declarada no if
	// e só existe dentro do escopo do if
	if b := 5; b < 10 {
		fmt.Println("b menor que 10")
	}

	// Switch case
	switch a {
	case 1:
		fmt.Println("a é 1")
		fallthrough // executa o próximo case mesmo que a condição não seja verdadeira
	case 2, 3, 4:
		fmt.Println("a é 2, 3 ou 4")
	case 6:
		fmt.Println("a é 6")
	default:
		fmt.Println("a é maior que 5")
	}

	// Switch sem expressão: útil para substituir longos if else if else
	switch {
	case a < 5:
		fmt.Println("a é menor que 5")
	case "abc" == "foo": // podemos usar expressões
		fmt.Println("a é igual a foo")
	case a > 5:
		fmt.Println("a é maior que 5")
	}

	// Variável declarada no switch só existe dentro do escopo do switch
	switch b := 5; {
	case b < 10:
		fmt.Println("b menor que 10")
	}
}

```

### Loops

Os Loops em Go são feitos com a palavra-chave **for**. Não existe while ou do while, mas podemos usar o for de forma que ele funcione como esses outros tipos de loop.

```go
func main() {
    // Loop for tradicional: inicialização, condição e incremento
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

    // Loop for usado como while: com apenas condição
	i := 0
	for i < 10 {
		i++
		fmt.Println(i)
	}

    // Loop for com range em array: pega index e valor
	arr := [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index, value)
	}

    // Loop for com range ignorando o index (_), pegando só o valor
	for _, value := range arr {
		fmt.Println(value)
	}

    // Loop for com range em número (0 até 9)
	for range 10 {
		fmt.Println("loop")
	}

    // Loop for com range em número (0 até 9) e pegando o index
	for index := range 10 {
		fmt.Println(index, "loop")
	}
}
```

## Conceitos Avançados

### Defer

A palavra-chave **defer** adia a execução de uma função até que a função que a contém retorne. Ou seja, o código marcado com **defer** só será executado no final, mesmo que esteja no meio da função.

```go
func defer() {
	// Adia a execução de uma função até o fim da função que a chamou
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("funcão principal")
	// saída:
	// função principal
	// defer 2
	// defer 1
}
```

### Ponteiros

Os ponteiros são uma maneira de referenciar a localização de uma variável na memória, ao invés de seu valor. Isso é útil quando queremos modificar o valor original de uma variável dentro de uma função.

Quando temos `*` na frente de um tipo, estamos dizendo que é um ponteiro. `ex: x *int,`

Quando temos `*` na frente de uma variável, estamos fazendo um dereference. `ex: *a`

```go
func main() {
	x := 10
	pointer := &x // &x é o endereço de memória da variável x
	fmt.Println(pointer, *pointer)
	//*pointer estou fazendo um dereference
	//ou seja, estou pegando o valor que está no endereço de memória
	//que a variável pointer (&x) está apontando

	take(&x) //passando o endereço de memória da variável x
	//dentro da função take, o valor que está no endereço de memória
	//da variável x será alterado para 20
	//pois estamos passando o endereço de memória da variável x
	//e dentro da função take, estamos alterando o valor que está nesse endereço de memória
	//se não fizéssemos isso, o valor de x continuaria 10
	//pois estaríamos passando uma cópia do valor de x
	//e não o endereço de memória de x
	fmt.Println(x)
}

// x *int é um ponteiro para um inteiro
func take(x *int) {
	*x = 20
}
```

# AINDA VOU MUDAR - ANOTAÇOES ANTIGAS

## Programação Orientada a Objetos

### Type & Receivers Function

Com **type**, conseguimos criar um novo tipo baseado em um tipo que já existe.

E com as funções receptoras (receiver functions), criamos métodos que as variáveis desse novo tipo podem usar.

-   main.go

```go
package main

func main() {
	friends := names{"Marcus", "Vitoria", "Luis"}
	friends.print()
}
```

-   names.go

```go
package main

import "fmt"

// Criamos o tipo 'names' baseado em um slice de string

type names []string

// Aqui estamos criando um método 'print' para o tipo 'names'

func (n names) print() {
	for _, name := range n {
		fmt.Println(name)
	}
}
```

### Structs

Em Go, structs são usadas pra agrupar dados relacionados, tipo um "modelo" ou "formato" de algo.

```go
type contactInfo struct {
	number int
	email  string
}

type person struct {
	firstName string
	lastName  string
	contact   contactInfo
}

func main() {
	marcus := person{"Marcus", "Coelho", contactInfo{999, "marcus@gmail.com"}}
	fmt.Println(marcus.firstName, marcus.lastName)
	fmt.Println(marcus.contact.email)
	fmt.Println(marcus.contact.number)
}
```

#### Structs com Ponteiros

Usamos ponteiros quando queremos modificar de verdade os valores de uma struct (ou qualquer variável) dentro de uma função.

Sem o ponteiro, o Go passa uma cópia da variável, então qualquer mudança não afeta o valor original. Com o ponteiro, acessamos diretamente o valor na memória e conseguimos alterar ele de fato.

-   Com **&variavel** pegamos o endereço de memória onde o valor dessa variável está guardado.
-   Com **\*ponteiro** acessamos o valor que está nesse endereço (ou seja, o valor para o qual o ponteiro aponta).
-   Tipo "o ponteiro é o endereço da casa, o valor é quem mora lá

```go
type person struct {
	firstName string
	lastName  string
}

func main() {
	marcus := person{"Marcus", "Coelho"}

	fmt.Println(marcus)

	marcus.changeName("Vitoria")

	fmt.Println(marcus)
}

func (pointerToPerson *person) changeName(newName string) {
	(*pointerToPerson).firstName = newName
}
```

Dica:

```
address: 10x0Abc
value: person{firstName: "Marcus"...}

Turn address into value with *address
Turn value into address with &value
```

#### Value Types & Reference Types

Value Types: int, float, string, boolean, structs

Reference Types: slices, maps, channels, pointers, functions

De forma resumida, em Value Types, precisamos usar ponteiros caso queiramos alterar seus valores por meio de funções.

Já em Reference Types, não precisamos nos preocupar com isso, pois, mesmo que seja criada uma cópia ao passá-los em uma função, essa cópia aponta para o mesmo endereço, então a modificação ocorre normalmente.

### Maps

Basicamente, Map é como se fosse um objeto do JavaScript, mas com algumas peculiaridades:

-   as chaves devem ser todas do mesmo tipo, e os valores também devem ser todos do mesmo tipo.

-   Se uma chave for **int**, todas têm que ser **int**;
-   Se um valor for **string**, todos os outros também têm que ser **string**.

```go
func main() {
	trafficLight := map[string]string{
		"red":    "stop",
		"yellow": "attention",
		"green":  "go",
	}

	fmt.Println(trafficLight)        // map[green:go red:stop yellow:attention]
	fmt.Println(trafficLight["red"]) // stop
}
```

Criando um Map vazio

```go
var colors map[string]string
// ou
colors := make(map[string]string)
```

Adicionando valor no Map

```go
colors["white"] = "#ffff";
```

Removendo valor no Map

```go
delete(colors, "white")
```

Iterando no Map

```go
func printMap(c map[string]string) {
	for key, value := range c {
		fmt.Println(key, value);
	}
}
```

### Interfaces

Interfaces servem pra gente definir um "contrato" de métodos que diferentes tipos precisam ter. É uma forma de criar um tipo mais genérico que aceita qualquer coisa que siga esse contrato.

No exemplo abaixo, criamos uma interface chamada **bot**, que exige que qualquer tipo que a implemente tenha o método **getGreeting()** que retorna uma **string**. Então, qualquer tipo que tiver esse método com essa assinatura já é considerado um bot, sem precisar declarar isso explicitamente.

```go
type bot interface {
	getGreeting() string
}

type englishBot struct{}
type spanishBot struct{}

func main() {
	eb := englishBot{}
	sb := spanishBot{}

	printGreeting(eb)
	printGreeting(sb)
}

func printGreeting(b bot) {
	fmt.Println(b.getGreeting())
}

func (englishBot) getGreeting() string {
	return "Hi there!"
}

func (spanishBot) getGreeting() string {
	return "Hola!"
}
```

Outro exemplo de interface

```go
type shape interface {
	getArea() float64
}

type triangle struct {
	height float64
	base   float64
}

type square struct {
	sideLength float64
}

func main() {
	sq := square{10}
	tr := triangle{10, 10}

	printArea(sq)
	printArea(tr)
}

func printArea(s shape) {
	fmt.Println(fmt.Sprintf("%v", s.getArea()))
}

func (t triangle) getArea() float64 {
	return t.height * t.base * 0.5
}

func (s square) getArea() float64 {
	return s.sideLength * s.sideLength
}
```

## Concorrência

### Go Routines

Basicamente, **Go Routines** são um método que utilizamos para rodar códigos de forma concorrente e, também, de forma paralela (nesse caso, só será paralelo se a CPU tiver mais de um núcleo; caso contrário, será apenas concorrente mesmo).

Por exemplo, imagine que eu tenha uma **slice com 5 links**, e um **for** que percorre essa slice fazendo um fetch desses links para saber se o status de cada um está ok ou não.

Da forma tradicional, temos uma **Blocking Call**, pois precisamos esperar o fetch do primeiro link terminar para começar o segundo, e esperar o segundo terminar para começar o terceiro - o que pode demorar bastante.

Então, o que podemos fazer é utilizar **Go Routines** para mitigar isso. Na nossa função que checa os links dentro do **for**, adicionamos a palavra-chave **go** antes. Ficaria algo assim:

```go
// Antes
for _, link := range links {
	checkLink(link)
}

// Depois
for _, link := range links {
	go checkLink(link)
}
```

A palavra-chave **go** so pode ser usada antes de funções.

Algo importante a se entender sobre **Go Routines** é que a função main (Main Routine) encerra sua execução assim que termina seu trabalho, independentemente de existirem outras Goroutines em execução. Ou seja, se a função main finalizar antes das Goroutines, o programa inteiro será encerrado, e essas tarefas paralelas serão interrompidas.

Por isso, quando estamos lidando com **Go Routines**, precisamos de alguma forma de sincronizar ou coordenar a execução entre elas - e é aí que entram os meios de comunicação entre **Go Routines**, como os **Channels**.

### Channels

Um **channel** em Go é uma forma segura de comunicação entre Go Routines. Uma coisa importante é que um channel só pode transmitir valores de um único tipo. Por exemplo, se você criar um channel de **string**, ele só poderá enviar e receber **strings**; o mesmo vale para **int**, **bool**, etc.

A comunicação com channels funciona da seguinte forma: primeiro você cria o channel, depois o passa para a função que será executada como Go Routine. Assim, ela consegue enviar (ou receber) dados por meio desse canal.

No exemplo abaixo, vamos supor que estamos verificando vários links com a função **checkLink()**. Aqui está como usamos um channel para isso:

```go
func main() {
	links := []string{
		"http://google.com",
		"http://facebook.com",
		"http://stackoverflow.com",
		"http://golang.org",
		"http://amazon.com",
	}

	// Criando o Channel
	c := make(chan string)

	for _, link := range links {
		go checkLink(link, c) // Passando o Channel na função
	}

	// Aqui esperamos a Main Routine aguarda alguma resposta do Channel
	fmt.Println(<-c)
}

// Adicionamos o parametro de Channel
func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- "Might be down I think" // Aqui enviamos uma string para o Channel
		return
	}

	fmt.Println(link, "is up!")
	c <- "Yep its up" // E aqui tambem
}
```

Mesmo que a gente tenha criado várias Go Routines com checkLink, se a função main não ficar esperando ativamente as respostas delas, o programa pode encerrar antes das Go Routines terminarem seu trabalho.

Para resolver isso, precisamos fazer com que o main espere uma resposta para cada Go Routine que criamos. Como sabemos quantos links estamos verificando, podemos usar um **for** com **len(links)** para receber exatamente o mesmo número de mensagens do channel:

```go
for i := 0; i < len(links); i++ {
	fmt.Println(<-c)  // Espera e imprime a mensagem de cada Go Routine
}
```

Também podemos fazer com que o programa fique verificando os links continuamente, de forma que ele nunca pare. Para isso, usamos um loop for que fica esperando por novas mensagens no channel. E como a operação `<-c` é bloqueante, o loop só prossegue quando uma nova mensagem for recebida - ou seja, ele não sai disparando um monte de Goroutines ao mesmo tempo descontroladamente.

```go
for {
	go checkLink(<-c, c)
}
func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- link // Reenvia o link
		return
	}

	fmt.Println(link, "is up!")
	c <- link // Reenvia o link
}
```

Podemos usar o **for range** para escutar continuamente o channel. Essa forma é bem comum em Go e funciona como um loop infinito que espera por mensagens no channel:

```go
for l := range c {
	go func(link string) {
		time.Sleep(5 * time.Second)
		checkLink(link, c)
	}(l) // temos que passar o l aqui pois se não ele sempre ficara com o mesmo valor e nao vai atualizar
}


func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- link // Agora retornamos o link
		return
	}

	fmt.Println(link, "is up!")
	c <- "Yep its up" // E aqui tambem
}
```

Por que passamos l como argumento da função anônima?

Se você usasse a variável **link** diretamente dentro da Goroutine, ela poderia não ter o valor esperado, por conta do comportamento de variáveis em loops e closures. Ao passar **l** como argumento para a função anônima, você garante que o valor certo de cada iteração será usado.

Se quiser entrar em contato comigo pra conversarmos sobre Go ou qualquer outra coisa, vou deixar meu contato abaixo. Valeu!

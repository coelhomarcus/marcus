Apesar de gostar muito de desenvolvimento front-end, provavelmente o que mais me da vontade de estudar √© back-end (e me divirto bem mais), visando isso estou estudando GO, e aqui est√° algumas das minhas anota√ß√µes.

Antes de irmos a fundo, quero citar algumas coisas que achei interessantes na linguagem. Come√ßando pela promessa de compatibilidade que o Go tem enraizada: eles n√£o tomam decis√µes que afetam vers√µes anteriores. Isso √© muito legal üëç

Outro ponto √© o Cross Compilation, que permite compilar para diversos sistemas operacionais independentemente do S.O. em que voc√™ estiver. Diferente do Electron, por exemplo (pelo menos at√© onde sei), onde, se quiser gerar um build para macOS, voc√™ precisa necessariamente ter um Mac.

Se tiver usando vscode: Ctrl + Shift + P ‚Üí Go Install/Update Tools

## B√°sicos da Linguagem

### Go CLI

-   `go mod init NomePasta` - Criando go.mod
-   `go run main.go` - Compila e executa o projeto
-   `go build main.go` - Compila o projeto
-   `go build -o "app" main.go` - Compila o projeto e nomeia como app.exe
-   `go get` - Instala algum package
-   `go install` - Compila e instala um package
-   `go test` - Roda algum teste relacionado ao projeto

## Packages e Organiza√ß√£o de C√≥digo

### Como os packages (pacotes) funcionam?

Em Go existem dois tipos de pacotes: **Execut√°veis** e **Reutiliz√°veis**

O `package main` √© um pacote execut√°vel, ele precisa ter uma fun√ß√£o main dentro, o nome do arquivo em si n√£o importa, poderia ser qualquercoisa.go mas se tiver a fun√ß√£o main ele √© o pacote execut√°vel. Esse √© o pacote principal, o que √© usado pra buildar o projeto.

Se tentar buildar um projeto com um pacote que n√£o seja o main, ele n√£o vai gerar o execut√°vel. E como saber se um pacote √© execut√°vel ou reutiliz√°vel?.

-   Se for `package main`, √© execut√°vel.
-   Qualquer outro nome, tipo `package utils`, `package math`, √© reutiliz√°vel, ou seja, c√≥digo que pode ser usado em outros lugares como se fosse uma depend√™ncia.

### Importa√ß√µes

```go

import "fmt"

import (
	"marcus/pacote"
	"fmt"
)


// Renomeando pacote na Importa√ß√£o
import (
	marcus "fmt"
)

func main() {
	//fmt.Println("Hello World");
	marcus.Println("Hello World");
}
```

### Criando um Pacote

Para criar um pacote, basta criar uma pasta com o nome desejado, por exemplo "alfabeto". Dentro dela, coloque os arquivos Go:

-   `a.go`
-   `b.go`

Em todos os arquivos dentro dessa pasta, a primeira linha deve declarar o mesmo pacote:

```go
package alfabeto
```

Se, por exemplo, voc√™ definir uma constante em `a.go`

```go
package alfabeto

const Idade = 30
```

Poder√° acess√°-la em outro arquivo importando o pacote:

```go
package main

import (
	"meuprojeto/alfabeto"
	"fmt"
)

func main() {
	fmt.Println(alfabeto.Idade) //30
}
```

Como todos os arquivos da pasta pertencem ao mesmo pacote, qualquer fun√ß√£o, constante ou vari√°vel exportada (iniciada com letra mai√∫scula) pode ser acessada ao importar o pacote.

#### Pacotes Internos

`Estrutura de pastas`

```
meuprojeto/
‚îÇ
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ pacote/
‚îÇ   ‚îú‚îÄ‚îÄ b.go
‚îÇ   ‚îî‚îÄ‚îÄ internal/
‚îÇ       ‚îî‚îÄ‚îÄ foo/
‚îÇ           ‚îî‚îÄ‚îÄ foo.go
```

`pacote/internal/foo/foo.go`

```go
package foo

// Essa vari√°vel s√≥ pode ser acessada dentro de "pacote"
var Minha = "Sou interna"
```

`pacote/b.go`

```go
package pacote

import (
	"fmt"
	"meuprojeto/pacote/internal/foo"
)

// Fun√ß√£o p√∫blica que usa a vari√°vel interna
func PrintMinha() {
	fmt.Println(foo.Minha)
}
```

`main.go`

```go
package main

import (
	"meuprojeto/pacote"
	"fmt"
)

func main() {
	// Correto: acessamos atrav√©s de b.go
	pacote.PrintMinha()

	// Errado: isso n√£o compila, acesso direto √© proibido
	// fmt.Println(foo.Minha)
	fmt.Println("N√£o √© poss√≠vel importar foo diretamente fora de 'pacote'")
}
```

## Tipos de Dados e Vari√°veis

### Variav√©is

Em Go, nomes que come√ßam com letra mai√∫scula s√£o exportados (p√∫blicos) e podem ser acessados fora do pacote.

```go
const name string = "Marcus" // Privada
const Name string = "Marcus" // P√∫blica

// Vari√°veis de escopo de pacote; N√£o precisam ser inicializadas nem usadas imediatamente
var global string

func main() {
    // Vari√°veis declaradas dentro de fun√ß√µes devem ser usadas depois de inicializadas;
	// caso contr√°rio, ocorre erro.
    var name2 string = "Marcus" // Tipo Expl√≠cito
    name3 := "Marcus"          // Infer√™ncia de Tipo (s√≥ em escopo de fun√ß√£o)

    // Declara√ß√£o m√∫ltipla de vari√°veis de tipos diferentes
    foo, bar := true, 50
}
```

Em Go n√£o existe undefined ou null como em outras linguagens. Se voc√™ n√£o inicializar a vari√°vel, ela vir√° com um **zero value** dependendo do tipo:

-   string ‚Üí ""
-   int ‚Üí 0
-   float ‚Üí 0
-   boolean ‚Üí false

Tipos em Go:

-   String: `string`
-   Boolean: `bool`
-   Inteiros: `int`, `int8`, `int16`, `int32`, `int64` e `uint`, `uint8`, `uint16`, `uint32`, `uint64`
-   Aliases: `byte` (equivalente a `uint8`), `rune` (equivalente a `int32`)
-   Ponto flutuante: `float32`, `float64`
-   N√∫meros complexos: `complex64`, `complex128`

Usando esses mesmos tipos podemos mudar o tipo de uma vari√°vel:

```go
var x int = 10
var y float64 = float64(x)
```

## Fun√ß√µes

### Fun√ß√µes B√°sicas

Criando uma fun√ß√£o que retorna string:

```go
func myName() string {
    return "Marcus"
}

// Quando n√£o colocamos o tipo na primeira vari√°vel, o Go entende que todas s√£o do mesmo tipo.
func abc(a, b int) {}

// Uma fun√ß√£o pode retornar 2 valores
func numbers() (int, int) {
	return 10, 20
}

// Podemos dar nome √†s vari√°veis de retorno. Isso ajuda na leitura e documenta√ß√£o.
func dividir(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return res, resto
}

// Naked return - N√£o √© encorajado usar!
// Como j√° nomeamos as vari√°veis de retorno, n√£o precisamos especific√°-las no return.
func dividirNaked(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return
}

func main() {
	// Fun√ß√µes An√¥nimas
	foo := func() {
		fmt.Println("Hello")
	}

	foo()
}
```

### Higher Order Functions

```go
func main() {
	x := somar(2)(1)
}

// Fun√ß√£o de higher order: retorna outra fun√ß√£o
// Essa fun√ß√£o retornada √© chamada de closure
func somar(a int) func(int) int {
	return func(b int) int {
		return a + b
	}
}
```

### Fun√ß√£o Vari√°tica

```go
// Fun√ß√£o vari√°tica: aceita 1 ou mais argumentos
func somarVariatica(nums ...int) int {
	var out int
	for _, n := range nums {
		out += n
	}
	return out
}

// somarVariatica(10, 10, 10) => 30
```

## Estruturas de Dados

### Arrays

Arrays tem tamanho fixo, nunca podem crescer ou diminuir

```go
	var arr1 [5]int
	var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
	arr3 := [5]int{3: 10} // inicializa o indice 3 com valor 10
	arr4 := [10]int{3: 10, 6: 20} // inicializa os indices 3 e 6 com valores 10 e 20
```

### Slices

Uma Slice √© uma vers√£o din√¢mica de um Array.

-   Use `Array` quando o tamanho da lista for fixo.
-   Use `Slice` quando o tamanho for vari√°vel.

Slices precisam ter todos os elementos do mesmo tipo.

Quando usamos `append()`, na real estamos criando uma nova Slice com o novo valor incluso e reatribuindo essa nova Slice pra mesma vari√°vel.

Pra iterar sobre uma Array ou Slice, usamos a palavra-chave `range` no loop, que percorre cada elemento.

```go
// Criando uma Slice a partir de um Array

arr := [5]int{1, 2, 3, 4, 5}
//criando o Slice pegando do index 1 a 3 do Array
//colocamos 4 pois ele descarta o ultimo
//nome disso: Slice Range Syntax
sliceArr := arr[1:4] // [2,3,4]
//mesmo alterando depois de criar o Slice, a Array tbm √© modificada
//pois apontam pro mesmo endere√ßo de memoria
arr[2] = 65
fmt.Println(sliceArr)

// Criando uma Slice

//para criar um slice basta apenas criar um array
//mas sem limitar os espa√ßos
slice := []int{1, 2, 3}
fmt.Println(slice)

// todo Slice tem Length e Capacity
// Length -> quantidade de elementos salvos no presente
// Capacity -> quantidade que o Slice pode armazenar sem fazer outra aloca√ß√£o
fmt.Println(slice, len(slice), cap(slice))
//Para adicionar um elemento no Slice criamos outro Slice e Reatribuimos
slice = append(slice, 2)
fmt.Println(slice, len(slice), cap(slice))

// Ao usar append em slices sem capacidade pr√©-alocada, cada vez que for necess√°rio
// aumentar o espa√ßo, o Go realocar√° a mem√≥ria e dobrar√° a capacidade do slice
// Em loops isso pode gerar muitas realoca√ß√µes, impactando negativamente a performance

// Uma forma mais eficiente de criar slices √© com make
// Com make podemos definir o tipo, o tamanho inicial (length) e a capacidade
// garantindo que o espa√ßo j√° esteja pr√©-alocado na mem√≥ria
// Essa abordagem √© √∫til principalmente quando sabemos previamente
// o tamanho do Slice
slicePerformatico := make([]string, 0, 10)
fmt.Println(slicePerformatico, len(slicePerformatico), cap(slicePerformatico))
```

### Map

O Map em GO basicamente √© o HashMap Padr√£o - Chave e Valor.

```go
func main() {
   //criando um Map
	m := make(map[string]string)
	mapWithSize := make(map[string]string, 100)

	//outro modo de criar um Map
	mLiteral := map[string]string{}
	mLiteralWithValues := map[string][]int{
		"Marcus": {1, 2, 3},
		// "Marcus": []int{1, 2, 3}, //mesma coisa
	}

   //acessando valores
   fmt.Println(mLiteralWithValues["Marcus"])
	fmt.Println(mLiteralWithValues["Marcus"][0])

   //adicionando mais valores
	mLiteralWithValues["Coelho"] = []int{4, 5, 6}
   fmt.Println(mLiteralWithValues["Coelho"])

  //podemos verificar a existencia da chave
	valor, seExiste := mLiteralWithValues["NaoExiste"]
	fmt.Println(seExiste) //true or false
	if seExiste {
		fmt.Println(valor)
	}

   //apagar Chave do Map
	delete(mLiteralWithValues, "Coelho")

   //limpa todas as chaves mas mantem a Capacity
   clear(mLiteralWithValues)

}
```

### Structs

Em Go, `structs` s√£o semelhantes a classes e s√£o declaradas com a keyword `type`. Cada campo √© definido em uma nova linha. M√©todos s√£o fun√ß√µes que recebem um receiver parameter, permitindo que sejam associados a um tipo espec√≠fico. Tamb√©m √© poss√≠vel usar embed para incorporar um tipo dentro de outro. Struct tags permitem controlar o comportamento de serializa√ß√£o, por exemplo, para JSON.

```go
type MinhaString string

type User struct {
	Name string
	ID   int
}

// Criando um m√©todo para o tipo User
func (u User) hello() {
	fmt.Println("Hello", u.Name)
}

func main() {
	// Inicializando uma struct User. Se n√£o inicializada, os valores vir√£o zerados
	user1 := User{"Marcus", 1}
	// Alternativa usando nomes de campos:
	// user1 := User{Name: "Marcus", ID: 1}

	fmt.Println(user1, user1.Name, user1.ID)
	user1.hello() // Output: Hello Marcus
}
```

Usando `Struct tags`

```go
// Struct tags indicam como os campos devem ser nomeados ao serializar para JSON
type Pet struct {
	Name string `json:"name"`
	ID   int    `json:"id"`
}


func main() {
   // Criando e serializando um Pet para JSON
	pet1 := Pet{"Cafundongo", 1}
	petJson, err := json.Marshal(pet1)

	if err != nil {
		panic(err)
	}

	fmt.Println(string(petJson))
   // Output: {"name":"Cafundongo","id":1}
}
```

### Interfaces

`Interfaces` em Go permitem definir comportamentos que diferentes tipos podem implementar.

Um tipo "satisfaz" uma interface automaticamente se possuir todos os `m√©todos` que ela exige.

No exemplo abaixo, `Dog` implementa a `interface Animal` porque define o `m√©todo Sound`.

Assim, podemos passar um `Dog` para qualquer fun√ß√£o que receba um Animal.

```go
type Animal interface {
	Sound() string
}

type Dog struct{}

func (Dog) Sound() string {
	return "Au! au!"
}

func whatDoesThisAnimalSay(a Animal) {
	fmt.Println(a.Sound())
}

func main() {
	dog := Dog{}
	whatDoesThisAnimalSay(dog)
}
```
#### Type Assertion e Type Switch

Interfaces permitem que diferentes tipos sejam tratados de forma gen√©rica.

Mas √†s vezes precisamos descobrir qual √© o tipo concreto por tr√°s da interface.

Para isso, podemos usar:
- Type Assertion: `a.(Tipo)` ex: `a.(string)` que retorna valor e ok
- Type Switch: `switch a.(type)`

```go
type Animal interface {
	Sound() string
}

type Dog struct{}

func (Dog) Sound() string {
	return "Au! au!"
}

type Cat struct{}

func (Cat) Sound() string {
	return "Miau!"
}

// Exemplo de Type Switch para identificar o tipo concreto
func takeAnimal(a Animal) string {
	switch t := a.(type) {
	case Dog:
		return "√â um cachorro: " + t.Sound()
	case Cat:
		return "√â um gato: " + t.Sound()
	default:
		return "Animal desconhecido"
	}
}

func main() {
	cat := Cat{}
	dog := Dog{}

	fmt.Println(takeAnimal(cat)) // √â um gato: Miau!
	fmt.Println(takeAnimal(dog)) // √â um cachorro: Au! au!
}
```



#### Any

O tipo `any` √© apenas um alias (apelido) para `interface{}`. Ou seja, type `any = interface{}` est√° definido no pacote padr√£o.

Mas usar any como tipo √© altamente desencorajado!

```go
func foo(a any) {
	fmt.Println(a)
}

func foo(a interface{}) {
	fmt.Println(a)
}

func main{
   minhaString := "Marcus"
   meuInt := 18
   meuSlice := []int{1,2,3}

   foo(minhaString)
   foo(meuInt)
   foo(meuSlice)
}
```



## Controle de Fluxo

### Condicionais

As condicionais em Go s√£o feitas com `if`, `else if`, `else` e `switch`.
N√£o tem diferencia entre else if e switch em termos de performance, ent√£o use o que fizer mais sentido pro seu caso.

```go
func main() {
	a := 10

	// Condicional if / else if / else
	if a > 5 {
		fmt.Println("maior que 5")
	} else if a < 5 {
		fmt.Println("menor que 5")
	} else {
		fmt.Println("igual a 5")
	}

	// Vari√°vel declarada no if
	// e s√≥ existe dentro do escopo do if
	if b := 5; b < 10 {
		fmt.Println("b menor que 10")
	}

	// Switch case
	switch a {
	case 1:
		fmt.Println("a √© 1")
		fallthrough // executa o pr√≥ximo case mesmo que a condi√ß√£o n√£o seja verdadeira
	case 2, 3, 4:
		fmt.Println("a √© 2, 3 ou 4")
	case 6:
		fmt.Println("a √© 6")
	default:
		fmt.Println("a √© maior que 5")
	}

	// Switch sem express√£o: √∫til para substituir longos if else if else
	switch {
	case a < 5:
		fmt.Println("a √© menor que 5")
	case "abc" == "foo": // podemos usar express√µes
		fmt.Println("a √© igual a foo")
	case a > 5:
		fmt.Println("a √© maior que 5")
	}

	// Vari√°vel declarada no switch s√≥ existe dentro do escopo do switch
	switch b := 5; {
	case b < 10:
		fmt.Println("b menor que 10")
	}
}

```

### Loops

Os Loops em Go s√£o feitos com a palavra-chave `for`. N√£o existe while ou do while, mas podemos usar o for de forma que ele funcione como esses outros tipos de loop.

```go
func main() {
    // Loop for tradicional: inicializa√ß√£o, condi√ß√£o e incremento
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

    // Loop for usado como while: com apenas condi√ß√£o
	i := 0
	for i < 10 {
		i++
		fmt.Println(i)
	}

    // Loop for com range em array: pega index e valor
	arr := [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index, value)
	}

    // Loop for com range ignorando o index (_), pegando s√≥ o valor
	for _, value := range arr {
		fmt.Println(value)
	}

    // Loop for com range em n√∫mero (0 at√© 9)
	for range 10 {
		fmt.Println("loop")
	}

    // Loop for com range em n√∫mero (0 at√© 9) e pegando o index
	for index := range 10 {
		fmt.Println(index, "loop")
	}
}
```
## Errors

#### Tratamento de Erros B√°sico

Em Go, erros s√£o representados por interfaces do tipo error. O tratamento de erros √© expl√≠cito e faz parte do fluxo do programa.

Fun√ß√µes que podem falhar geralmente retornam dois valores: o resultado e um error.

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    res, err := dividir(3, 0)

    if err != nil {
        fmt.Println("Ocorreu um erro:", err)
        // Pode tratar o erro de acordo com a situa√ß√£o
        return
    }

    fmt.Println("Resultado da divis√£o:", res)
}

// dividir retorna o resultado da divis√£o de a por b, ou um erro caso b seja zero.
func dividir(a, b int) (int, error) {
    if b == 0 {
        // Criando um novo erro com errors.New
        return 0, errors.New("n√£o pode dividir por zero")
    }

    return a / b, nil
}
```

#### Errors Is e Errors As

```go
import (
	"errors"
	"fmt"
)

// Exemplo de uso de errors.Is e errors.As

var ErrValorInvalido = errors.New("valor inv√°lido")

// Tipo de erro customizado
type MeuErro struct {
	Msg string
}

func (e *MeuErro) Error() string {
	return e.Msg
}

// Exemplo errors.Is
func main() {
	err := ErrValorInvalido
	if errors.Is(err, ErrValorInvalido) {
		fmt.Println("errors.Is: O erro √© ErrValorInvalido")
	}
}

// Exemplo errors.As
func main() {
   var err error = &MeuErro{"erro personalizado"}
	var meuErr *MeuErro
	if errors.As(err, &meuErr) {
		fmt.Println("errors.As: O erro √© do tipo MeuErro:", meuErr.Msg)
	}
}
```

#### Errors Join

```go
func main() {
	err1 := errors.New("erro 1")
	err2 := errors.New("erro 2")

	// Agrupando m√∫ltiplos erros em um s√≥
	combined := errors.Join(err1, err2)

	fmt.Println("Erros agrupados:", combined)
	// Sa√≠da: Erros agrupados: erro 1; erro 2

	// Checando se um dos erros est√° presente no agrupado
	if errors.Is(combined, err1) {
		fmt.Println("O erro 1 est√° presente dentro do erro combinado")
	}
}
```

#### Errors Wrappers

```go
func dividir(a, b int) (int, error) {
	if b == 0 {
		// Erro original
		erroOriginal := errors.New("divis√£o por zero")
		// Adiciona contexto ao erro original
		return 0, fmt.Errorf("erro ao dividir %d por %d: %w", a, b, erroOriginal)
	}
	return a / b, nil
}

func main() {
	_, err := dividir(10, 0)
	if err != nil {
		fmt.Println("Error wrapping:", err)
		// Checando se o erro original est√° presente
		erroOriginal := errors.New("divis√£o por zero")
		if errors.Is(err, erroOriginal) {
			fmt.Println("Error wrapping: O erro original est√° presente na cadeia de erros!")
		}
	}
}
```

## Readers & Writers

- O padr√£o Reader/Writer √© muito comum em Go.
- Qualquer struct que implemente `Write([]byte) (int, error)` √© um Writer.
- Qualquer struct que implemente `Read([]byte) (int, error)` √© um Reader.
- Existem fun√ß√µes utilit√°rias do pacote io, como:
    - `io.ReadAll(reader)` l√™ tudo de uma vez s√≥
    - `io.ReadFull(reader, buffer)` l√™ o buffer at√© estar cheio ou EOF
- Usar essas interfaces permite criar c√≥digo gen√©rico para leitura e escrita de dados.

```go
package main

import (
	"errors"
	"fmt"
	"io"
	"strings"
)

// Exemplo b√°sico de Readers & Writers em Go

func main() {
	str := "hello, world!"
	reader := strings.NewReader(str) // Cria um Reader baseado em string
	writer := MyWriter{}             // Nosso Writer customizado

	buffer := make([]byte, 2) // Buffer de 2 bytes

	for {
		n, err := reader.Read(buffer)
		if err != nil {
			if errors.Is(err, io.EOF) {
				break // Fim da leitura
			}
			panic(err) // Outro erro
		}
		// Em vez de Println(string(buffer[:n])), usamos um Writer customizado
		_, _ = writer.Write(buffer[:n])
	}
}

// Implementando a interface io.Writer
type MyWriter struct{}

// O m√©todo Write recebe um slice de bytes,
// imprime como string e retorna quantidade de bytes lidos
func (MyWriter) Write(b []byte) (int, error) {
	fmt.Print(string(b))
	return len(b), nil
}
```

## Conceitos Avan√ßados

### Defer

A palavra-chave `defer` adia a execu√ß√£o de uma fun√ß√£o at√© que a fun√ß√£o que a cont√©m retorne. Ou seja, o c√≥digo marcado com `defer` s√≥ ser√° executado no final, mesmo que esteja no meio da fun√ß√£o.

```go
func defer() {
	// Adia a execu√ß√£o de uma fun√ß√£o at√© o fim da fun√ß√£o que a chamou
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("func√£o principal")
	// sa√≠da:
	// fun√ß√£o principal
	// defer 2
	// defer 1
}
```

### Ponteiros

Os ponteiros s√£o uma maneira de referenciar a localiza√ß√£o de uma vari√°vel na mem√≥ria, ao inv√©s de seu valor. Isso √© √∫til quando queremos modificar o valor original de uma vari√°vel dentro de uma fun√ß√£o.

Quando temos `*` na frente de um tipo, estamos dizendo que √© um ponteiro. `ex: x *int,`

Quando temos `*` na frente de uma vari√°vel, estamos fazendo um dereference. `ex: *a`

```go
func main() {
	x := 10
	pointer := &x // &x √© o endere√ßo de mem√≥ria da vari√°vel x
	fmt.Println(pointer, *pointer)
	//*pointer estou fazendo um dereference
	//ou seja, estou pegando o valor que est√° no endere√ßo de mem√≥ria
	//que a vari√°vel pointer (&x) est√° apontando

	take(&x) //passando o endere√ßo de mem√≥ria da vari√°vel x
	//dentro da fun√ß√£o take, o valor que est√° no endere√ßo de mem√≥ria
	//da vari√°vel x ser√° alterado para 20
	//pois estamos passando o endere√ßo de mem√≥ria da vari√°vel x
	//e dentro da fun√ß√£o take, estamos alterando o valor que est√° nesse endere√ßo de mem√≥ria
	//se n√£o fiz√©ssemos isso, o valor de x continuaria 10
	//pois estar√≠amos passando uma c√≥pia do valor de x
	//e n√£o o endere√ßo de mem√≥ria de x
	fmt.Println(x)
}

// x *int √© um ponteiro para um inteiro
func take(x *int) {
	*x = 20
}
```





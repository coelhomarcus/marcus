Apesar de gostar muito de desenvolvimento front-end, provavelmente o que mais me da vontade de estudar √© back-end (e me divirto bem mais), visando isso estou estudando GO, e aqui est√° algumas das minhas anota√ß√µes.

Antes de irmos a fundo, quero citar algumas coisas que achei interessantes na linguagem. Come√ßando pela promessa de compatibilidade que o Go tem enraizada: eles n√£o tomam decis√µes que afetam vers√µes anteriores. Isso √© muito legal üòéüëç

Outro ponto √© o Cross Compilation, que permite compilar para diversos sistemas operacionais independentemente do S.O. em que voc√™ estiver. Diferente do Electron, por exemplo (pelo menos at√© onde sei), onde, se quiser gerar um build para macOS, voc√™ precisa necessariamente ter um Mac.

Se tiver usando vscode:

`Ctrl + Shift + P ‚Üí Go Install/Update Tools`

### Go CLI

-   **go mod init NomePasta** - Criando go.mod
-   **go run main.go** - Compila e executa o projeto
-   **go build main.go** - Compila o projeto
-   **go build -o "app" main.go** - Compila o projeto e nomeia como app.exe
-   **go get** - Instala algum package
-   **go install** - Compila e instala um package
-   **go test** - Roda algum teste relacionado ao projeto

### Como os packages (pacotes) funcionam?

Em Go existem dois tipos de pacotes: **Execut√°veis** e **Reutiliz√°veis**

O **package main** √© um pacote execut√°vel, ele precisa ter uma fun√ß√£o main dentro, o nome do arquivo em si n√£o importa, poderia ser qualquercoisa.go mas se tiver a fun√ß√£o main ele √© o pacote execut√°vel. Esse √© o pacote principal, o que √© usado pra buildar o projeto.

Se tentar buildar um projeto com um pacote que n√£o seja o main, ele n√£o vai gerar o execut√°vel. E como saber se um pacote √© execut√°vel ou reutiliz√°vel?.

-   Se for **package main**, √© execut√°vel.
-   Qualquer outro nome, tipo **package utils**, **package math**, √© reutiliz√°vel, ou seja, c√≥digo que pode ser usado em outros lugares como se fosse uma depend√™ncia.

### Importa√ß√µes

```go

import "fmt"

import (
	"marcus/pacote"
	"fmt"
)


// Renomeando pacote na Importa√ß√£o
import (
	marcus "fmt"
)

func main() {
	//fmt.Println("Hello World");
	marcus.Println("Hello World");
}
```

### Criando um Pacote

Para criar um pacote, basta criar uma pasta com o nome desejado, por exemplo "alfabeto". Dentro dela, coloque os arquivos Go:

-   a.go
-   b.go

Em todos os arquivos dentro dessa pasta, a primeira linha deve declarar o mesmo pacote:

```go
package alfabeto
```

Se, por exemplo, voc√™ definir uma constante em **a.go**

```go
package alfabeto

const Idade = 30
```

Poder√° acess√°-la em outro arquivo importando o pacote:

```go
package main

import (
	"meuprojeto/alfabeto"
	"fmt"
)

func main() {
	fmt.Println(alfabeto.Idade) //30
}
```

Como todos os arquivos da pasta pertencem ao mesmo pacote, qualquer fun√ß√£o, constante ou vari√°vel exportada (iniciada com letra mai√∫scula) pode ser acessada ao importar o pacote.

### Pacotes Internos

**Estrutura de pastas**

```
meuprojeto/
‚îÇ
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ pacote/
‚îÇ   ‚îú‚îÄ‚îÄ b.go
‚îÇ   ‚îî‚îÄ‚îÄ internal/
‚îÇ       ‚îî‚îÄ‚îÄ foo/
‚îÇ           ‚îî‚îÄ‚îÄ foo.go
```

**pacote/internal/foo/foo.go**

```go
package foo

// Essa vari√°vel s√≥ pode ser acessada dentro de "pacote"
var Minha = "Sou interna"
```

**pacote/b.go**

```go
package pacote

import (
	"fmt"
	"meuprojeto/pacote/internal/foo"
)

// Fun√ß√£o p√∫blica que usa a vari√°vel interna
func PrintMinha() {
	fmt.Println(foo.Minha)
}
```

**main.go**

```go
package main

import (
	"meuprojeto/pacote"
	"fmt"
)

func main() {
	// Correto: acessamos atrav√©s de b.go
	pacote.PrintMinha()

	// Errado: isso n√£o compila, acesso direto √© proibido
	// fmt.Println(foo.Minha)
	fmt.Println("N√£o √© poss√≠vel importar foo diretamente fora de 'pacote'")
}
```

### Variav√©is

Em Go, nomes que come√ßam com letra mai√∫scula s√£o exportados (p√∫blicos) e podem ser acessados fora do pacote.

```go
const name string = "Marcus" // Privada
const Name string = "Marcus" // P√∫blica

// Vari√°veis de escopo de pacote; N√£o precisam ser inicializadas nem usadas imediatamente
var global string

func main() {
    // Vari√°veis declaradas dentro de fun√ß√µes devem ser usadas depois de inicializadas;
	// caso contr√°rio, ocorre erro.
    var name2 string = "Marcus" // Tipo Expl√≠cito
    name3 := "Marcus"          // Infer√™ncia de Tipo (s√≥ em escopo de fun√ß√£o)

    // Declara√ß√£o m√∫ltipla de vari√°veis de tipos diferentes
    foo, bar := true, 50
}
```

Em Go n√£o existe undefined ou null como em outras linguagens. Se voc√™ n√£o inicializar a vari√°vel, ela vir√° com um **zero value** dependendo do tipo:

-   string ‚Üí ""
-   int ‚Üí 0
-   float ‚Üí 0
-   boolean ‚Üí false

Tipos em Go:

-   String: `string`
-   Boolean: `bool`
-   Inteiros: `int`, `int8`, `int16`, `int32`, `int64` e `uint`, `uint8`, `uint16`, `uint32`, `uint64`
-   Aliases: `byte` (equivalente a `uint8`), `rune` (equivalente a `int32`)
-   Ponto flutuante: `float32`, `float64`
-   N√∫meros complexos: `complex64`, `complex128`

Usando esses mesmos tipos podemos mudar o tipo de uma vari√°vel:

```go
var x int = 10
var y float64 = float64(x)
```

### Fun√ß√µes

Criando uma fun√ß√£o que retorna string:

```go
func myName() string {
    return "Marcus"
}

// Quando n√£o colocamos o tipo na primeira vari√°vel, o Go entende que todas s√£o do mesmo tipo.
func abc(a, b int) {}

// Uma fun√ß√£o pode retornar 2 valores
func numbers() (int, int) {
	return 10, 20
}

// Podemos dar nome √†s vari√°veis de retorno. Isso ajuda na leitura e documenta√ß√£o.
func dividir(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return res, resto
}

// Naked return - N√£o √© encorajado usar!
// Como j√° nomeamos as vari√°veis de retorno, n√£o precisamos especific√°-las no return.
func dividirNaked(a, b int) (res, resto int) {
	res = a / b
	resto = a % b
	return
}

func main() {
	// Fun√ß√µes An√¥nimas
	foo := func() {
		fmt.Println("Hello")
	}

	foo()
}
```

### Fun√ß√£o Higher Order

```go
func main() {
	x := somar(2)(1)
}

// Fun√ß√£o de higher order: retorna outra fun√ß√£o
// Essa fun√ß√£o retornada √© chamada de closure
func somar(a int) func(int) int {
	return func(b int) int {
		return a + b
	}
}
```

### Fun√ß√£o Vari√°tica

```go
// Fun√ß√£o vari√°tica: aceita 1 ou mais argumentos
func somarVariatica(nums ...int) int {
	var out int
	for _, n := range nums {
		out += n
	}
	return out
}

// somarVariatica(10, 10, 10) => 30
```

### Array

Arrays tem tamanho fixo, nunca podem crescer ou diminuir

```go
	var arr1 [5]int
	var arr2 [5]int = [5]int{1, 2, 3, 4, 5}
	arr3 := [5]int{3: 10} // inicializa o indice 3 com valor 10
	arr4 := [10]int{3: 10, 6: 20} // inicializa os indices 3 e 6 com valores 10 e 20
```

### Slice

Uma Slice √© uma vers√£o mais flex√≠vel de um Array.

-   Use `Array` quando o tamanho da lista for fixo.
-   Use `Slice` quando o tamanho for vari√°vel - j√° que d√° pra adicionar ou remover elementos com facilidade.

Slices precisam ter todos os elementos do mesmo tipo: se come√ßou com **int**, tudo tem que ser **int**;

Quando usamos **append()**, na real estamos criando uma nova Slice com o novo valor incluso e reatribuindo essa nova Slice pra mesma vari√°vel.

Pra iterar sobre uma Array ou Slice, usamos a palavra-chave **range** no loop, que percorre cada elemento.

```go
// Criando uma Slice

names := []string{"Marcus", myName(), "Vitoria"}

// Adicionando novo elemento na Slice

names = append(names, "Coelho")

//Iterando pela Slice

for index, name := range names {
    fmt.Println(index, name);
}

//Iterando sem index

for _, name := range names {
    fmt.Println(name);
}
```

### Slice Range Syntax

Esse esquema de fatia (slice) √© muito √∫til quando queremos pegar s√≥ uma parte da lista.

Detalhe importante: o segundo n√∫mero n√£o √© incluso, ent√£o 0:2 pega o √≠ndice 0 e 1.

```go
fruits := []string{"Ma√ß√£", "Pera", "Banana", "Uva"}

// Do √≠ndice 0 at√© o 2 (mas sem incluir o 2)

fruits[0:2] == ["Ma√ß√£", "Pera"]
fruits[:2]   == ["Ma√ß√£", "Pera"]

// A partir do √≠ndice 2 (incluindo o 2) at√© o fim

fruits[2:] == ["Banana", "Uva"]
```

### Condicionais

As condicionais em Go s√£o feitas com **if**, **else if**, **else** e **switch**.
N√£o tem diferencia entre else if e switch em termos de performance, ent√£o use o que fizer mais sentido pro seu caso.

```go
func main() {
	a := 10

	// Condicional if / else if / else
	if a > 5 {
		fmt.Println("maior que 5")
	} else if a < 5 {
		fmt.Println("menor que 5")
	} else {
		fmt.Println("igual a 5")
	}

	// Vari√°vel declarada no if
	// e s√≥ existe dentro do escopo do if
	if b := 5; b < 10 {
		fmt.Println("b menor que 10")
	}

	// Switch case
	switch a {
	case 1:
		fmt.Println("a √© 1")
		fallthrough // executa o pr√≥ximo case mesmo que a condi√ß√£o n√£o seja verdadeira
	case 2, 3, 4:
		fmt.Println("a √© 2, 3 ou 4")
	case 6:
		fmt.Println("a √© 6")
	default:
		fmt.Println("a √© maior que 5")
	}

	// Switch sem express√£o: √∫til para substituir longos if else if else
	switch {
	case a < 5:
		fmt.Println("a √© menor que 5")
	case "abc" == "foo": // podemos usar express√µes
		fmt.Println("a √© igual a foo")
	case a > 5:
		fmt.Println("a √© maior que 5")
	}

	// Vari√°vel declarada no switch s√≥ existe dentro do escopo do switch
	switch b := 5; {
	case b < 10:
		fmt.Println("b menor que 10")
	}
}

```

### Loops

Os Loops em Go s√£o feitos com a palavra-chave **for**. N√£o existe while ou do while, mas podemos usar o for de forma que ele funcione como esses outros tipos de loop.

```go
func main() {
    // Loop for tradicional: inicializa√ß√£o, condi√ß√£o e incremento
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}

    // Loop for usado como while: com apenas condi√ß√£o
	i := 0
	for i < 10 {
		i++
		fmt.Println(i)
	}

    // Loop for com range em array: pega index e valor
	arr := [5]int{1, 2, 3, 4, 5}
	for index, value := range arr {
		fmt.Println(index, value)
	}

    // Loop for com range ignorando o index (_), pegando s√≥ o valor
	for _, value := range arr {
		fmt.Println(value)
	}

    // Loop for com range em n√∫mero (0 at√© 9)
	for range 10 {
		fmt.Println("loop")
	}

    // Loop for com range em n√∫mero (0 at√© 9) e pegando o index
	for index := range 10 {
		fmt.Println(index, "loop")
	}
}
```

### Defer

A palavra-chave **defer** adia a execu√ß√£o de uma fun√ß√£o at√© que a fun√ß√£o que a cont√©m retorne. Ou seja, o c√≥digo marcado com **defer** s√≥ ser√° executado no final, mesmo que esteja no meio da fun√ß√£o.

```go
func defer() {
	// Adia a execu√ß√£o de uma fun√ß√£o at√© o fim da fun√ß√£o que a chamou
	defer fmt.Println("defer 1")
	defer fmt.Println("defer 2")
	fmt.Println("func√£o principal")
	// sa√≠da:
	// fun√ß√£o principal
	// defer 2
	// defer 1
}
```

### Type & Receivers Function

Com **type**, conseguimos criar um novo tipo baseado em um tipo que j√° existe.

E com as fun√ß√µes receptoras (receiver functions), criamos m√©todos que as vari√°veis desse novo tipo podem usar.

-   main.go

```go
package main

func main() {
	friends := names{"Marcus", "Vitoria", "Luis"}
	friends.print()
}
```

-   names.go

```go
package main

import "fmt"

// Criamos o tipo 'names' baseado em um slice de string

type names []string

// Aqui estamos criando um m√©todo 'print' para o tipo 'names'

func (n names) print() {
	for _, name := range n {
		fmt.Println(name)
	}
}
```

### Structs

Em Go, structs s√£o usadas pra agrupar dados relacionados, tipo um "modelo" ou "formato" de algo.

```go
type contactInfo struct {
	number int
	email  string
}

type person struct {
	firstName string
	lastName  string
	contact   contactInfo
}

func main() {
	marcus := person{"Marcus", "Coelho", contactInfo{999, "marcus@gmail.com"}}
	fmt.Println(marcus.firstName, marcus.lastName)
	fmt.Println(marcus.contact.email)
	fmt.Println(marcus.contact.number)
}
```

### Structs com Ponteiros

Usamos ponteiros quando queremos modificar de verdade os valores de uma struct (ou qualquer vari√°vel) dentro de uma fun√ß√£o.

Sem o ponteiro, o Go passa uma c√≥pia da vari√°vel, ent√£o qualquer mudan√ßa n√£o afeta o valor original. Com o ponteiro, acessamos diretamente o valor na mem√≥ria e conseguimos alterar ele de fato.

-   Com **&variavel** pegamos o endere√ßo de mem√≥ria onde o valor dessa vari√°vel est√° guardado.
-   Com **\*ponteiro** acessamos o valor que est√° nesse endere√ßo (ou seja, o valor para o qual o ponteiro aponta).
-   Tipo "o ponteiro √© o endere√ßo da casa, o valor √© quem mora l√°

```go
type person struct {
	firstName string
	lastName  string
}

func main() {
	marcus := person{"Marcus", "Coelho"}

	fmt.Println(marcus)

	marcus.changeName("Vitoria")

	fmt.Println(marcus)
}

func (pointerToPerson *person) changeName(newName string) {
	(*pointerToPerson).firstName = newName
}
```

Dica:

```
address: 10x0Abc
value: person{firstName: "Marcus"...}

Turn address into value with *address
Turn value into address with &value
```

### Value Types & Reference Types

Value Types: int, float, string, boolean, structs

Reference Types: slices, maps, channels, pointers, functions

De forma resumida, em Value Types, precisamos usar ponteiros caso queiramos alterar seus valores por meio de fun√ß√µes.

J√° em Reference Types, n√£o precisamos nos preocupar com isso, pois, mesmo que seja criada uma c√≥pia ao pass√°-los em uma fun√ß√£o, essa c√≥pia aponta para o mesmo endere√ßo, ent√£o a modifica√ß√£o ocorre normalmente.

### Map

Basicamente, Map √© como se fosse um objeto do JavaScript, mas com algumas peculiaridades:

-   as chaves devem ser todas do mesmo tipo, e os valores tamb√©m devem ser todos do mesmo tipo.

-   Se uma chave for **int**, todas t√™m que ser **int**;
-   Se um valor for **string**, todos os outros tamb√©m t√™m que ser **string**.

```go
func main() {
	trafficLight := map[string]string{
		"red":    "stop",
		"yellow": "attention",
		"green":  "go",
	}

	fmt.Println(trafficLight)        // map[green:go red:stop yellow:attention]
	fmt.Println(trafficLight["red"]) // stop
}
```

Criando um Map vazio

```go
var colors map[string]string
// ou
colors := make(map[string]string)
```

Adicionando valor no Map

```go
colors["white"] = "#ffff";
```

Removendo valor no Map

```go
delete(colors, "white")
```

Iterando no Map

```go
func printMap(c map[string]string) {
	for key, value := range c {
		fmt.Println(key, value);
	}
}
```

### Interfaces

Interfaces servem pra gente definir um "contrato" de m√©todos que diferentes tipos precisam ter. √â uma forma de criar um tipo mais gen√©rico que aceita qualquer coisa que siga esse contrato.

No exemplo abaixo, criamos uma interface chamada **bot**, que exige que qualquer tipo que a implemente tenha o m√©todo **getGreeting()** que retorna uma **string**. Ent√£o, qualquer tipo que tiver esse m√©todo com essa assinatura j√° √© considerado um bot, sem precisar declarar isso explicitamente.

```go
type bot interface {
	getGreeting() string
}

type englishBot struct{}
type spanishBot struct{}

func main() {
	eb := englishBot{}
	sb := spanishBot{}

	printGreeting(eb)
	printGreeting(sb)
}

func printGreeting(b bot) {
	fmt.Println(b.getGreeting())
}

func (englishBot) getGreeting() string {
	return "Hi there!"
}

func (spanishBot) getGreeting() string {
	return "Hola!"
}
```

Outro exemplo de interface

```go
type shape interface {
	getArea() float64
}

type triangle struct {
	height float64
	base   float64
}

type square struct {
	sideLength float64
}

func main() {
	sq := square{10}
	tr := triangle{10, 10}

	printArea(sq)
	printArea(tr)
}

func printArea(s shape) {
	fmt.Println(fmt.Sprintf("%v", s.getArea()))
}

func (t triangle) getArea() float64 {
	return t.height * t.base * 0.5
}

func (s square) getArea() float64 {
	return s.sideLength * s.sideLength
}
```

### Go Routines

Basicamente, **Go Routines** s√£o um m√©todo que utilizamos para rodar c√≥digos de forma concorrente e, tamb√©m, de forma paralela (nesse caso, s√≥ ser√° paralelo se a CPU tiver mais de um n√∫cleo; caso contr√°rio, ser√° apenas concorrente mesmo).

Por exemplo, imagine que eu tenha uma **slice com 5 links**, e um **for** que percorre essa slice fazendo um fetch desses links para saber se o status de cada um est√° ok ou n√£o.

Da forma tradicional, temos uma **Blocking Call**, pois precisamos esperar o fetch do primeiro link terminar para come√ßar o segundo, e esperar o segundo terminar para come√ßar o terceiro - o que pode demorar bastante.

Ent√£o, o que podemos fazer √© utilizar **Go Routines** para mitigar isso. Na nossa fun√ß√£o que checa os links dentro do **for**, adicionamos a palavra-chave **go** antes. Ficaria algo assim:

```go
// Antes
for _, link := range links {
	checkLink(link)
}

// Depois
for _, link := range links {
	go checkLink(link)
}
```

A palavra-chave **go** so pode ser usada antes de fun√ß√µes.

Algo importante a se entender sobre **Go Routines** √© que a fun√ß√£o main (Main Routine) encerra sua execu√ß√£o assim que termina seu trabalho, independentemente de existirem outras Goroutines em execu√ß√£o. Ou seja, se a fun√ß√£o main finalizar antes das Goroutines, o programa inteiro ser√° encerrado, e essas tarefas paralelas ser√£o interrompidas.

Por isso, quando estamos lidando com **Go Routines**, precisamos de alguma forma de sincronizar ou coordenar a execu√ß√£o entre elas - e √© a√≠ que entram os meios de comunica√ß√£o entre **Go Routines**, como os **Channels**.

### Channels

Um **channel** em Go √© uma forma segura de comunica√ß√£o entre Go Routines. Uma coisa importante √© que um channel s√≥ pode transmitir valores de um √∫nico tipo. Por exemplo, se voc√™ criar um channel de **string**, ele s√≥ poder√° enviar e receber **strings**; o mesmo vale para **int**, **bool**, etc.

A comunica√ß√£o com channels funciona da seguinte forma: primeiro voc√™ cria o channel, depois o passa para a fun√ß√£o que ser√° executada como Go Routine. Assim, ela consegue enviar (ou receber) dados por meio desse canal.

No exemplo abaixo, vamos supor que estamos verificando v√°rios links com a fun√ß√£o **checkLink()**. Aqui est√° como usamos um channel para isso:

```go
func main() {
	links := []string{
		"http://google.com",
		"http://facebook.com",
		"http://stackoverflow.com",
		"http://golang.org",
		"http://amazon.com",
	}

	// Criando o Channel
	c := make(chan string)

	for _, link := range links {
		go checkLink(link, c) // Passando o Channel na fun√ß√£o
	}

	// Aqui esperamos a Main Routine aguarda alguma resposta do Channel
	fmt.Println(<-c)
}

// Adicionamos o parametro de Channel
func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- "Might be down I think" // Aqui enviamos uma string para o Channel
		return
	}

	fmt.Println(link, "is up!")
	c <- "Yep its up" // E aqui tambem
}
```

Mesmo que a gente tenha criado v√°rias Go Routines com checkLink, se a fun√ß√£o main n√£o ficar esperando ativamente as respostas delas, o programa pode encerrar antes das Go Routines terminarem seu trabalho.

Para resolver isso, precisamos fazer com que o main espere uma resposta para cada Go Routine que criamos. Como sabemos quantos links estamos verificando, podemos usar um **for** com **len(links)** para receber exatamente o mesmo n√∫mero de mensagens do channel:

```go
for i := 0; i < len(links); i++ {
	fmt.Println(<-c)  // Espera e imprime a mensagem de cada Go Routine
}
```

Tamb√©m podemos fazer com que o programa fique verificando os links continuamente, de forma que ele nunca pare. Para isso, usamos um loop for que fica esperando por novas mensagens no channel. E como a opera√ß√£o `<-c` √© bloqueante, o loop s√≥ prossegue quando uma nova mensagem for recebida - ou seja, ele n√£o sai disparando um monte de Goroutines ao mesmo tempo descontroladamente.

```go
for {
	go checkLink(<-c, c)
}
func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- link // Reenvia o link
		return
	}

	fmt.Println(link, "is up!")
	c <- link // Reenvia o link
}
```

Podemos usar o **for range** para escutar continuamente o channel. Essa forma √© bem comum em Go e funciona como um loop infinito que espera por mensagens no channel:

```go
for l := range c {
	go func(link string) {
		time.Sleep(5 * time.Second)
		checkLink(link, c)
	}(l) // temos que passar o l aqui pois se n√£o ele sempre ficara com o mesmo valor e nao vai atualizar
}


func checkLink(link string, c chan string) {
	_, err := http.Get(link)
	if err != nil {
		fmt.Println(link, "might be down!")
		c <- link // Agora retornamos o link
		return
	}

	fmt.Println(link, "is up!")
	c <- "Yep its up" // E aqui tambem
}
```

Por que passamos l como argumento da fun√ß√£o an√¥nima?

Se voc√™ usasse a vari√°vel **link** diretamente dentro da Goroutine, ela poderia n√£o ter o valor esperado, por conta do comportamento de vari√°veis em loops e closures. Ao passar **l** como argumento para a fun√ß√£o an√¥nima, voc√™ garante que o valor certo de cada itera√ß√£o ser√° usado.

Se quiser entrar em contato comigo pra conversarmos sobre Go ou qualquer outra coisa, vou deixar meu contato abaixo. Valeu!

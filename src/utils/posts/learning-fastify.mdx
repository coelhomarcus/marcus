Atualmente estou cursando Web II na faculdade e surgiu a curiosidade de estudar Fastify, já que será o framework que utilizaremos para desenvolver APIs em Node. Por isso, decidi me adiantar e começar a estudá-lo antecipadamente. Neste post, vou deixar minhas anotações, que estão sujeitas a mudanças.

Apenas um adendo: apesar deste post conter minhas anotações, vou deixar um link para a [documentação oficial do Fastify](https://fastify.dev/docs/latest/), pois há muitos tópicos e nem todos conseguirei abordar aqui.

### Instalando Fastify

```bash
npm init -y

npm install fastify
```

### Criando rotas GET e POST simples

```js
import Fastify from "fastify";

// Instanciando o Fastify
const fastify = Fastify({
    logger: true,
});

// Definindo rotas GET e POST
fastify.get("/", async (req, reply) => {
    return "Oi, Fastify!";
});

fastify.post("/data", async (req, reply) => {
    const data = req.body;
    return { requestBody: data };
});

//Iniciando
const start = async () => {
    try {
        await fastify.listen({ port: 3000 });
        console.log(`Server rodando na http://localhost:3000`);
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};

start();
```

### Criando rota GET com reply.send

No fastify é utilizado tanto o return e o reply.send para as response, as duas estão corretas, geralmente para coisas simples é usado o return mesmo.

```js
fastify.get("/reply", async (req, reply) => {
    return reply.send("Oi, Fastify com reply!");
});
```

### Criando uma rota GET com fastify.route

Essa é uma forma mais robusta de definir uma rota.

```js
fastify.route({
    method: "GET",
    url: "/route",
    schema: {
        // a requisição precisa ter uma querystring com o parâmetro `name`
        // localhost:3000/route?name=Marcus
        querystring: {
            type: "object",
            properties: {
                name: { type: "string" },
            },
            required: ["name"],
        },
        // a resposta será um objeto com a propriedade `hello` do tipo string
        response: {
            200: {
                type: "object",
                properties: {
                    hello: { type: "string" },
                },
            },
            400: {
                type: "object",
                properties: {
                    message: { type: "string" },
                },
            },
        },
    },
    // essa função é executada antes do handler em cada requisição
    preHandler: async (request, reply) => {
        //exemplo: checar autenticação
    },
    // essa função é executada quando a requisição é feita
    handler: async (request, reply) => {
        return { hello: request.query.name };
    },
});
```

### Hooks

Hooks são funções que são executadas em determinados momentos do ciclo de vida de uma requisição. Eles podem ser usados para adicionar funcionalidades como autenticação, logging, validação, etc.

```js
fastify.addHook("preHandler", async (request, reply) => {
    // Aqui você pode adicionar lógica que deve ser executada antes do handler
    // Por exemplo, você pode verificar se o usuário está autenticado
});

fastify.addHook("onResponse", async (request, reply) => {
    // Aqui você pode adicionar lógica que deve ser executada após a resposta ser enviada
    // Por exemplo, você pode registrar informações sobre a requisição
});

fastify.addHook("onError", (request, reply, error, done) => {
    // Aqui você pode adicionar lógica que deve ser executada quando ocorrer um erro
    // Por exemplo, você pode logar o erro ou enviar uma notificação
    done();
});
```

Para mais informações sobre **Hooks** &rarr; [Documentação Fastify - Hooks](https://fastify.dev/docs/latest/Reference/Hooks/)

### Decorators

#### decorateRequest

O decorateRequest tem como objetivo adicionar novas propriedades ao objeto request

```js
// Aqui estamos adicionando a propriedade "user" do tipo string
// O segundo argumento passado é o valor padrão de "user"
// Esse tipo de decoração é útil quando utilizamos TypeScript para tipar a propriedade e evitar erros
fastify.decorateRequest("user", "");

// Aqui estamos populando a propriedade "user" antes de cada requisição
// Esse hook é executado antes do handler da rota
// O terceiro argumento "done" é uma função que deve ser chamada para continuar o fluxo
// Parecido com o next() do Express
fastify.addHook("preHandler", (req, reply, done) => {
    req.user = "Marcus Coelho";
    done();
});

// Acessando a propriedade "user" dentro do handler da rota
fastify.get("/", (req, reply) => {
    reply.send(`Hello, ${req.user}!`);
    // "Hello, Marcus Coelho!"
});
```

#### decorate

O método decorate tem como objetivo adicionar novas funcionalidades ao objeto fastify

```js
// Aqui estamos adicionando a função "utility" ao objeto fastify
// Essa função pode ser chamada em qualquer lugar do código
// Esse tipo de decoração é útil para adicionar funcionalidades
// que serão utilizadas em várias partes da aplicação
fastify.decorate("utility", function () {
    return console.log("Isso é uma função utilitária");
});

fastify.utility(); // "Isso é uma função utilitária"
```

Mas não apenas funções podem ser adicionadas, qualquer tipo de dado pode ser adicionado

```js
fastify.decorate("appName", "Cafuntalk");
console.log(fastify.appName); // "Cafuntalk"

// Outro exemplo
// Aqui estamos adicionando a propriedade "conf" ao objeto fastify
// Essa propriedade é um objeto que contém as configurações da aplicação
fastify.decorate("conf", {
    db: "database.db",
    port: 3000,
});

console.log(fastify.conf.db + " " + fastify.conf.port);
```

Para mais informações sobre **Decorators** &rarr; [Documentação Fastify - Decorators](https://fastify.dev/docs/latest/Reference/Decorators/)

Se quiser conversar sobre programação ou qualquer assunto relacionado, fique à vontade para entrar em contato!
